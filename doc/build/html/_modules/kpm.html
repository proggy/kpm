

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>kpm &mdash; kpm 0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="kpm 0.1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">kpm 0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for kpm</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c"># Copyright notice</span>
<span class="c"># ----------------</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2013-2014 Daniel Jung</span>
<span class="c"># Contact: djungbremen@gmail.com</span>
<span class="c">#</span>
<span class="c"># This program is free software; you can redistribute it and/or modify it</span>
<span class="c"># under the terms of the GNU General Public License as published by the Free</span>
<span class="c"># Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="c"># any later version.</span>
<span class="c">#</span>
<span class="c"># This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c"># ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="c"># FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for</span>
<span class="c"># more details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License along</span>
<span class="c"># with this program; if not, write to the Free Software Foundation, Inc.,</span>
<span class="c"># 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="c">#</span>
<span class="sd">&quot;&quot;&quot;Implement the kernel polynomial method (KPM) [1].</span>

<span class="sd">Right now, KPM algorithms for the following target quantities are provided:</span>

<span class="sd">    - Density of states (DOS)</span>
<span class="sd">    - Local density of states (LDOS)</span>

<span class="sd">By averaging (arithmetic or geometric mean), also the following quantities</span>
<span class="sd">can be calculated:</span>

<span class="sd">    - Arithmetic mean of the LDOS (ALDOS)</span>
<span class="sd">    - Geometric mean of the LDOS (GLDOS)</span>

<span class="sd">The algorithms expect either tight binding matrices, or supercell definitions</span>
<span class="sd">as defined in the module :mod:`sc` which provide rules to create a matrix &quot;on</span>
<span class="sd">the fly&quot;.</span>

<span class="sd">Certain submodules are written in Cython [2] to obtain better performance and</span>
<span class="sd">allow for OpenMP parallelization.</span>

<span class="sd">References:</span>

<span class="sd">    - [1] Wei√üe et al., Rev. Mod. Phys. 78, 275 (2006)</span>
<span class="sd">    - [2] http://cython.org/</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c">#</span>
<span class="c"># To do:</span>
<span class="c"># --&gt; implement other reconstruction methods (fct, fft, dft)</span>
<span class="c"># --&gt; by choice, return cofunc objects</span>
<span class="c"># --&gt; implement the &quot;stochastical method&quot; to compute ADOS</span>
<span class="c"># --&gt; keep rescaling factors</span>
<span class="c">#</span>
<span class="n">__created__</span> <span class="o">=</span> <span class="s">&#39;2013-07-06&#39;</span>
<span class="n">__modified__</span> <span class="o">=</span> <span class="s">&#39;2014-02-28&#39;</span>
<span class="c"># former tb.kpm2 (developed 2012-08-06 until 2013-06-25)</span>
<span class="c"># based on tb.kpm, developed from 2011-10-11 until 2012-06-27,</span>
<span class="c"># which itself is the former tbc.pyx from 2011-04-14 until 2011-05-17</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">h5obj.tools</span>
<span class="kn">import</span> <span class="nn">oalg</span>
<span class="kn">import</span> <span class="nn">progress</span>
<span class="kn">import</span> <span class="nn">dummy</span>

<span class="c"># import submodules</span>
<span class="kn">import</span> <span class="nn">disc</span>
<span class="kn">import</span> <span class="nn">kern</span>
<span class="kn">import</span> <span class="nn">misc</span>
<span class="kn">import</span> <span class="nn">mom</span>
<span class="kn">import</span> <span class="nn">rcstr</span>
<span class="kn">import</span> <span class="nn">resc</span>
<span class="kn">import</span> <span class="nn">svect</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">frog</span> <span class="kn">import</span> <span class="n">Frog</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">Frog</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="n">Decorator</span>


<span class="c"># algorithms directly interfacing fast Cython implementations</span>
<span class="c"># - ldos</span>
<span class="c"># - dos</span>

<span class="c"># algorithms that use LDOS as an input</span>
<span class="c"># - aldos</span>
<span class="c"># - gldos</span>
<span class="c"># - galdos</span>

<span class="c"># algorithms that use DOS as an input</span>
<span class="c"># - ados</span>


<span class="c"># common frog configuration</span>
<span class="n">shortopts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">erange</span><span class="o">=</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">rcstr</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="s">&#39;l&#39;</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="s">&#39;m&#39;</span><span class="p">,</span>
                 <span class="n">num_threads</span><span class="o">=</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="n">spr</span><span class="o">=</span><span class="s">&#39;p&#39;</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="s">&#39;o&#39;</span><span class="p">,</span>
                 <span class="n">stateclass</span><span class="o">=</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
<span class="n">longopts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;rcstr&#39;</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="s">&#39;num-threads&#39;</span><span class="p">)</span>
<span class="n">opttypes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">enum</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                <span class="n">spr</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                <span class="n">rcount</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">rsmooth</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="n">optdoc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">erange</span><span class="o">=</span><span class="s">&#39;energy range&#39;</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;select kernel&#39;</span><span class="p">,</span>
              <span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;select reconstruction method (std, dct, ...)&#39;</span><span class="p">,</span>
              <span class="n">limit</span><span class="o">=</span><span class="s">&#39;truncation limit of Chebychev expansion&#39;</span><span class="p">,</span>
              <span class="n">omp</span><span class="o">=</span><span class="s">&#39;use OpenMP parallelized algorithms (if available)&#39;</span><span class="p">,</span>
              <span class="n">num_threads</span><span class="o">=</span><span class="s">&#39;number of OpenMP threads to use. &#39;</span> <span class="o">+</span>
                          <span class="s">&#39;If smaller than 1, choose automatically &#39;</span> <span class="o">+</span>
                          <span class="s">&#39;according to the number of CPU cores&#39;</span><span class="p">,</span>
              <span class="n">until</span><span class="o">=</span><span class="s">&#39;confine execution time&#39;</span><span class="p">,</span>
              <span class="n">enum</span><span class="o">=</span><span class="s">&#39;number of energy discretization steps&#39;</span><span class="p">,</span>
              <span class="n">estep</span><span class="o">=</span><span class="s">&#39;energy stepwidth&#39;</span><span class="p">,</span>
              <span class="n">count</span><span class="o">=</span><span class="s">&#39;abort when given LDOS count has been reached &#39;</span> <span class="o">+</span>
                    <span class="s">&#39;(sample size)&#39;</span><span class="p">,</span>
              <span class="n">tol</span><span class="o">=</span><span class="s">&#39;abort when result is converged within given tolerance&#39;</span><span class="p">,</span>
              <span class="n">spr</span><span class="o">=</span><span class="s">&#39;number of states per disorder realization taken into &#39;</span> <span class="o">+</span>
                  <span class="s">&#39;account&#39;</span><span class="p">,</span>
              <span class="n">smooth</span><span class="o">=</span><span class="s">&#39;set smoothness level for convergence criterion &#39;</span> <span class="o">+</span>
                     <span class="s">&#39;(--tol)&#39;</span><span class="p">,</span>
              <span class="n">stateclass</span><span class="o">=</span><span class="s">&#39;restrict selection of states to a certain state &#39;</span> <span class="o">+</span>
                         <span class="s">&#39;class. By default, select all&#39;</span><span class="p">,</span>
              <span class="n">init_dens</span><span class="o">=</span><span class="s">&#39;continue a previous calculation&#39;</span><span class="p">,</span>
              <span class="n">init_var</span><span class="o">=</span><span class="s">&#39;continue a previous calculation&#39;</span><span class="p">,</span>
              <span class="n">init_count</span><span class="o">=</span><span class="s">&#39;continue a previous calculation&#39;</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="s">&#39;with --count, show progress bar, &#39;</span> <span class="o">+</span>
                      <span class="s">&#39;with --tol, monitor count and accuracy&#39;</span><span class="p">,</span>
              <span class="n">rescaled</span><span class="o">=</span><span class="s">&#39;do not rescale, given matrix is already rescaled &#39;</span> <span class="o">+</span>
                       <span class="s">&#39;(its spectrum fits into the interval [-1, 1])&#39;</span><span class="p">)</span>


<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="s">&#39;$0/scell&#39;</span><span class="p">),</span>
      <span class="n">preproc</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="k">lambda</span> <span class="n">scell</span><span class="p">:</span> <span class="n">scell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&#39;csr&#39;</span><span class="p">)),</span>
      <span class="n">outmap</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;$0/lenerg&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;$0/ldens&#39;</span><span class="p">},</span>
      <span class="n">opttypes</span><span class="o">=</span><span class="n">opttypes</span><span class="p">,</span> <span class="n">longopts</span><span class="o">=</span><span class="n">longopts</span><span class="p">,</span> <span class="n">shortopts</span><span class="o">=</span><span class="n">shortopts</span><span class="p">,</span>
      <span class="n">optdoc</span><span class="o">=</span><span class="n">optdoc</span><span class="p">)</span>
<div class="viewcode-block" id="ldos"><a class="viewcode-back" href="../index.html#kpm.ldos">[docs]</a><span class="k">def</span> <span class="nf">ldos</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;jackson&#39;</span><span class="p">,</span> <span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;std&#39;</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">rescaled</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stateclass</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate local density of states (LDOS) from the given tight binding</span>
<span class="sd">    matrix. Return energy and density array.&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-06 until 2014-01-14</span>
    <span class="c"># former tb.kpm2._ldos (developed 2012-08-25 until 2013-06-25)</span>
    <span class="c"># former tb.kpm._Ldos (developed 2011-11-23 until 2012-03-14)</span>
    <span class="c"># former tb._Ldos from 2011-02-20 until 2011-05-10</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enum</span> <span class="ow">and</span> <span class="n">estep</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">enum</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">estep</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;enum&quot; and &quot;estep&quot; must be specified&#39;</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">)</span> \
        <span class="k">else</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expecting square matrix&#39;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">erange</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">rescaled</span> <span class="k">else</span> <span class="n">misc</span><span class="o">.</span><span class="n">symmetric_interval</span><span class="p">(</span><span class="n">erange</span><span class="p">)</span>
    <span class="n">mat</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="n">erange</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                               <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span> \
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rescaled</span> <span class="k">else</span> <span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
    <span class="n">rcstr_func</span> <span class="o">=</span> <span class="n">rcstr</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">rcstr_method</span><span class="p">)</span>
    <span class="n">kernel_func</span> <span class="o">=</span> <span class="n">kern</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">energ</span> <span class="o">=</span> <span class="n">_get_energ</span><span class="p">(</span><span class="n">rcstr_func</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span> <span class="n">estep</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">rcstr_args</span><span class="p">,</span> <span class="n">rcstr_kwargs</span> <span class="o">=</span> <span class="n">_get_rcstr_args</span><span class="p">(</span><span class="n">rcstr_func</span><span class="p">,</span> <span class="n">energ</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span>
                                               <span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">svect</span><span class="o">.</span><span class="n">ind</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">moments</span> <span class="o">=</span> <span class="n">mom</span><span class="o">.</span><span class="n">expec</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
    <span class="n">kernel_func</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="n">rcstr_func</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="o">*</span><span class="n">rcstr_args</span><span class="p">,</span> <span class="o">**</span><span class="n">rcstr_kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">energ</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">inverse_rescale</span><span class="p">(</span><span class="n">energ</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">energ</span><span class="p">,</span> <span class="n">dens</span>

</div>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="s">&#39;$0/scell&#39;</span><span class="p">),</span>
      <span class="n">preproc</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="k">lambda</span> <span class="n">scell</span><span class="p">:</span> <span class="n">scell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&#39;csr&#39;</span><span class="p">)),</span>
      <span class="n">outmap</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;$0/lenerg&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;$0/ldens&#39;</span><span class="p">},</span>
      <span class="n">opttypes</span><span class="o">=</span><span class="n">opttypes</span><span class="p">,</span> <span class="n">longopts</span><span class="o">=</span><span class="n">longopts</span><span class="p">,</span> <span class="n">shortopts</span><span class="o">=</span><span class="n">shortopts</span><span class="p">,</span>
      <span class="n">optdoc</span><span class="o">=</span><span class="n">optdoc</span><span class="p">)</span>
<div class="viewcode-block" id="ldos_vm"><a class="viewcode-back" href="../index.html#kpm.ldos_vm">[docs]</a><span class="k">def</span> <span class="nf">ldos_vm</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">varmom</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;jackson&#39;</span><span class="p">,</span> <span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;std&#39;</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">rescaled</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stateclass</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate local density of states (LDOS) using the given tight binding</span>
<span class="sd">    matrix *mat* and the energy-dependent number of Chebychev moments *varmom*.</span>
<span class="sd">    Return energy and density array.&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-06 until 2014-01-14</span>
    <span class="c"># former tb.kpm2._ldos (developed 2012-08-25 until 2013-06-25)</span>
    <span class="c"># former tb.kpm._Ldos (developed 2011-11-23 until 2012-03-14)</span>
    <span class="c"># former tb._Ldos from 2011-02-20 until 2011-05-10</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enum</span> <span class="ow">and</span> <span class="n">estep</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">enum</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">estep</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;enum&quot; or &quot;estep&quot; must be given&#39;</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">)</span> \
        <span class="k">else</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expecting square matrix&#39;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">erange</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">rescaled</span> <span class="k">else</span> <span class="n">misc</span><span class="o">.</span><span class="n">symmetric_interval</span><span class="p">(</span><span class="n">erange</span><span class="p">)</span>
    <span class="n">mat</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="n">erange</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                               <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span> \
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rescaled</span> <span class="k">else</span> <span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
    <span class="n">rcstr_func</span> <span class="o">=</span> <span class="n">rcstr</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">rcstr_method</span><span class="p">)</span>
    <span class="n">kernel_func</span> <span class="o">=</span> <span class="n">kern</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">energ</span> <span class="o">=</span> <span class="n">_get_energ</span><span class="p">(</span><span class="n">rcstr_func</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span> <span class="n">estep</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">energ</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">varmom</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;length of &quot;varmom&quot; inconsistent with number of &#39;</span> <span class="o">+</span>
                         <span class="s">&#39;energies&#39;</span><span class="p">)</span>
    <span class="n">rcstr_args</span><span class="p">,</span> <span class="n">rcstr_kwargs</span> <span class="o">=</span> <span class="n">_get_rcstr_args</span><span class="p">(</span><span class="n">rcstr_func</span><span class="p">,</span> <span class="n">energ</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span>
                                               <span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">svect</span><span class="o">.</span><span class="n">ind</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mat</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">moments</span> <span class="o">=</span> <span class="n">mom</span><span class="o">.</span><span class="n">expec</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">varmom</span><span class="p">),</span> <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span>
                        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
    <span class="c">### kernel is also depending on &quot;varmom&quot;!</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="n">kernel_func</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="n">rcstr_func</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="o">*</span><span class="n">rcstr_args</span><span class="p">,</span> <span class="o">**</span><span class="n">rcstr_kwargs</span><span class="p">)</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">energ</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">inverse_rescale</span><span class="p">(</span><span class="n">energ</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">energ</span><span class="p">,</span> <span class="n">dens</span>

</div>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">scell</span><span class="o">=</span><span class="s">&#39;$0/scell&#39;</span><span class="p">,</span> <span class="n">init_dens</span><span class="o">=</span><span class="s">&#39;$0/adens&#39;</span><span class="p">,</span> <span class="n">init_var</span><span class="o">=</span><span class="s">&#39;$0/avar&#39;</span><span class="p">,</span>
                 <span class="n">init_count</span><span class="o">=</span><span class="s">&#39;$0/acount&#39;</span><span class="p">),</span>
      <span class="n">outmap</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;$0/alenerg&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;$0/aldens&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#39;$0/alvar&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">&#39;$0/alcount&#39;</span><span class="p">,</span>
              <span class="mi">4</span><span class="p">:</span> <span class="s">&#39;$0/alacc&#39;</span><span class="p">},</span>
      <span class="n">opttypes</span><span class="o">=</span><span class="n">opttypes</span><span class="p">,</span> <span class="n">longopts</span><span class="o">=</span><span class="n">longopts</span><span class="p">,</span> <span class="n">shortopts</span><span class="o">=</span><span class="n">shortopts</span><span class="p">,</span>
      <span class="n">optdoc</span><span class="o">=</span><span class="n">optdoc</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<div class="viewcode-block" id="aldos"><a class="viewcode-back" href="../index.html#kpm.aldos">[docs]</a><span class="k">def</span> <span class="nf">aldos</span><span class="p">(</span><span class="n">scell</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
          <span class="n">smooth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;jackson&#39;</span><span class="p">,</span> <span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;std&#39;</span><span class="p">,</span>
          <span class="n">stateclass</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">spr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
          <span class="n">until</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
          <span class="n">init_dens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_var</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_count</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate arithmetic mean of local density of states (ALDOS).&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-22 until 2013-07-24</span>
    <span class="c"># based on tb.kpm2._aldos (developed 2012-09-03 until 2013-06-20)</span>
    <span class="c"># based on tb.kpm._Ados (developed from 2012-04-26 until 2012-07-16) and</span>
    <span class="c">#          tb.kpm._Gdos (developed from 2011-12-20 until 2012-07-17)</span>
    <span class="c"># based on tb.kpm._Gdos from 2011-12-20 until 2012-04-18</span>

    <span class="c">### compare complete parameter sets? warn when continuing calculation?</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="ow">and</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;count&quot; or &quot;tol&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enum</span> <span class="ow">and</span> <span class="n">estep</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">enum</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">estep</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;enum&quot; or &quot;estep&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init_dens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">init_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> \
            <span class="o">+</span> <span class="p">(</span><span class="n">init_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;either all 3 init values have to be given or &#39;</span> <span class="o">+</span>
                         <span class="s">&#39;None at all&#39;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">progress</span><span class="o">.</span><span class="n">Abort</span><span class="p">()</span> <span class="k">as</span> <span class="n">abort</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Converge</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span> <span class="k">as</span> <span class="n">converge</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Until</span><span class="p">(</span><span class="n">until</span><span class="p">)</span> <span class="k">as</span> <span class="n">until</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Terminate</span><span class="p">()</span> <span class="k">as</span> <span class="n">term</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Monitor</span><span class="p">(</span><span class="n">formats</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">acc</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%g</span><span class="s">&#39;</span><span class="p">),</span>
                         <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;smooth&#39;</span><span class="p">,</span> <span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="s">&#39;acc&#39;</span><span class="p">],</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">tol</span><span class="p">))</span> <span class="k">as</span> <span class="n">mon</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;calculate ALDOS&#39;</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">count</span><span class="p">))</span> <span class="k">as</span> <span class="n">bar</span><span class="p">:</span>

        <span class="c"># as soon as the matrix has been rescaled for the first time and a</span>
        <span class="c"># rescaled energy array is retrieved from the core module, set this</span>
        <span class="c"># to True</span>
        <span class="c"># so this is True when at least one for-loop iteration has been done</span>
        <span class="n">scaleback</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">oalg</span><span class="o">.</span><span class="n">Mean</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">init_dens</span><span class="p">,</span> <span class="n">init_count</span><span class="o">=</span><span class="n">init_count</span><span class="p">,</span>
                         <span class="n">init_var</span><span class="o">=</span><span class="n">init_var</span><span class="p">)</span>

        <span class="c"># the progress bar may jump ahead if a fixed sample size is given</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>

        <span class="c">#size = scell.size()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">energ</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># cycle realizations</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tol</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">converge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">count</span> <span class="ow">or</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">mat</span><span class="p">,</span> <span class="n">stateclasses</span> <span class="o">=</span> <span class="n">scell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">(</span><span class="n">distinguish</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">_get_stateclass</span><span class="p">(</span><span class="n">stateclass</span><span class="p">,</span> <span class="n">stateclasses</span><span class="p">)</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
            <span class="c">#erange = get_erange(erange, mat)</span>
            <span class="n">mat</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="n">erange</span><span class="p">,</span>
                                       <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                                       <span class="c">### copy=False not working???</span>
            <span class="n">estep2</span> <span class="o">=</span> <span class="n">estep</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">estep</span> <span class="k">else</span> <span class="bp">None</span>

            <span class="c"># cycle states</span>
            <span class="k">for</span> <span class="n">sind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">spr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">or</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">or</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                        <span class="ow">or</span> <span class="p">(</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">converge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> \
                        <span class="ow">or</span> <span class="p">(</span><span class="n">count</span> <span class="ow">and</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c"># calculate LDOS</span>
                <span class="c"># erange isn&#39;t needed if rescaled is True</span>
                <span class="n">energ</span><span class="p">,</span> <span class="n">dens</span> <span class="o">=</span> <span class="n">ldos</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">rescaled</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                   <span class="n">rcstr_method</span><span class="o">=</span><span class="n">rcstr_method</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="n">enum</span><span class="p">,</span>
                                   <span class="n">estep</span><span class="o">=</span><span class="n">estep2</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
                                   <span class="n">state</span><span class="o">=</span><span class="n">inds</span><span class="p">[</span><span class="n">sind</span><span class="p">],</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                <span class="n">scaleback</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">mean</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dens</span><span class="o">.</span><span class="n">real</span><span class="o">/</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
                           <span class="n">acc</span><span class="o">=</span><span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>
                <span class="n">bar</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">scaleback</span><span class="p">:</span>
            <span class="n">energ</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">inverse_rescale</span><span class="p">(</span><span class="n">energ</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">set_delay</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">abort</span><span class="p">):</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">energ</span><span class="p">,</span> <span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">mean</span><span class="o">.</span><span class="n">var</span><span class="p">(),</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">()</span>

</div>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">scell</span><span class="o">=</span><span class="s">&#39;$0/scell&#39;</span><span class="p">,</span> <span class="n">init_dens</span><span class="o">=</span><span class="s">&#39;$0/gdens&#39;</span><span class="p">,</span> <span class="n">init_var</span><span class="o">=</span><span class="s">&#39;$0/gvar&#39;</span><span class="p">,</span>
                 <span class="n">init_count</span><span class="o">=</span><span class="s">&#39;$0/gcount&#39;</span><span class="p">),</span>
      <span class="n">outmap</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;$0/glenerg&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;$0/gldens&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#39;$0/glvar&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">&#39;$0/glcount&#39;</span><span class="p">,</span>
              <span class="mi">4</span><span class="p">:</span> <span class="s">&#39;$0/glacc&#39;</span><span class="p">},</span>
      <span class="n">opttypes</span><span class="o">=</span><span class="n">opttypes</span><span class="p">,</span> <span class="n">longopts</span><span class="o">=</span><span class="n">longopts</span><span class="p">,</span> <span class="n">shortopts</span><span class="o">=</span><span class="n">shortopts</span><span class="p">,</span>
      <span class="n">optdoc</span><span class="o">=</span><span class="n">optdoc</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<div class="viewcode-block" id="gldos"><a class="viewcode-back" href="../index.html#kpm.gldos">[docs]</a><span class="k">def</span> <span class="nf">gldos</span><span class="p">(</span><span class="n">scell</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
          <span class="n">smooth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;jackson&#39;</span><span class="p">,</span> <span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;std&#39;</span><span class="p">,</span>
          <span class="n">stateclass</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">spr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
          <span class="n">until</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
          <span class="n">init_dens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_var</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_count</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate geometric mean of local density of states (GLDOS) (also known</span>
<span class="sd">    as the typical density of states).&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-24 - 2013-07-29</span>
    <span class="c"># based on tb2.kpm.aldos (developed 2013-07-22 until 2013-07-24)</span>
    <span class="c"># based on tb.kpm2._aldos (developed 2012-09-03 until 2013-06-20)</span>
    <span class="c"># based on tb.kpm._Ados (developed from 2012-04-26 until 2012-07-16) and</span>
    <span class="c">#          tb.kpm._Gdos (developed from 2011-12-20 until 2012-07-17)</span>
    <span class="c"># based on tb.kpm._Gdos from 2011-12-20 until 2012-04-18</span>

    <span class="c">### compare complete parameter sets? warn when continuing calculation?</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="ow">and</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;count&quot; or &quot;tol&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enum</span> <span class="ow">and</span> <span class="n">estep</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">enum</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">estep</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;enum&quot; or &quot;estep&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init_dens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">init_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> \
            <span class="o">+</span> <span class="p">(</span><span class="n">init_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;either all 3 init values have to be given or none &#39;</span> <span class="o">+</span>
                         <span class="s">&#39;at all&#39;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">progress</span><span class="o">.</span><span class="n">Abort</span><span class="p">()</span> <span class="k">as</span> <span class="n">abort</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Converge</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span> <span class="k">as</span> <span class="n">converge</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Until</span><span class="p">(</span><span class="n">until</span><span class="p">)</span> <span class="k">as</span> <span class="n">until</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Terminate</span><span class="p">()</span> <span class="k">as</span> <span class="n">term</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Monitor</span><span class="p">(</span><span class="n">formats</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">acc</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%g</span><span class="s">&#39;</span><span class="p">),</span>
                         <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;smooth&#39;</span><span class="p">,</span> <span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="s">&#39;acc&#39;</span><span class="p">],</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">tol</span><span class="p">))</span> <span class="k">as</span> <span class="n">mon</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;calculate GLDOS&#39;</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">count</span><span class="p">))</span> <span class="k">as</span> <span class="n">bar</span><span class="p">:</span>

        <span class="c"># as soon as the matrix has been rescaled for the first time and a</span>
        <span class="c"># rescaled energy array is retrieved from the core module, set this</span>
        <span class="c"># to True</span>
        <span class="c"># so this is True when at least one for-loop iteration has been done</span>
        <span class="n">scaleback</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">oalg</span><span class="o">.</span><span class="n">gMean</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">init_dens</span><span class="p">,</span> <span class="n">init_count</span><span class="o">=</span><span class="n">init_count</span><span class="p">,</span>
                          <span class="n">init_var</span><span class="o">=</span><span class="n">init_var</span><span class="p">)</span>

        <span class="c"># the progress bar may jump ahead if a fixed sample size is given</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>

        <span class="c">#size = scell.size()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">energ</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># cycle realizations</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tol</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">converge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">count</span> <span class="ow">or</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">mat</span><span class="p">,</span> <span class="n">stateclasses</span> <span class="o">=</span> <span class="n">scell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">(</span><span class="n">distinguish</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">_get_stateclass</span><span class="p">(</span><span class="n">stateclass</span><span class="p">,</span> <span class="n">stateclasses</span><span class="p">)</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
            <span class="c">#erange = get_erange(erange, mat)</span>
            <span class="n">mat</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="n">erange</span><span class="p">,</span>
                                       <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                                       <span class="c">### copy=False not working???</span>
            <span class="n">estep2</span> <span class="o">=</span> <span class="n">estep</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">estep</span> <span class="k">else</span> <span class="bp">None</span>

            <span class="c"># cycle states</span>
            <span class="k">for</span> <span class="n">sind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">spr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">or</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">or</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                        <span class="ow">or</span> <span class="p">(</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">converge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> \
                        <span class="ow">or</span> <span class="p">(</span><span class="n">count</span> <span class="ow">and</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c"># calculate LDOS</span>
                <span class="c"># erange isn&#39;t needed if rescaled is True</span>
                <span class="n">energ</span><span class="p">,</span> <span class="n">dens</span> <span class="o">=</span> <span class="n">ldos</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">rescaled</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                   <span class="n">rcstr_method</span><span class="o">=</span><span class="n">rcstr_method</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="n">enum</span><span class="p">,</span>
                                   <span class="n">estep</span><span class="o">=</span><span class="n">estep2</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
                                   <span class="n">state</span><span class="o">=</span><span class="n">inds</span><span class="p">[</span><span class="n">sind</span><span class="p">],</span>
                                   <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                <span class="n">scaleback</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">rdens</span> <span class="o">=</span> <span class="n">dens</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
                <span class="n">mean</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rdens</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>  <span class="c"># because sometimes small</span>
                                            <span class="c"># negative values occur</span>

                <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
                           <span class="n">acc</span><span class="o">=</span><span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>
                <span class="n">bar</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">scaleback</span><span class="p">:</span>
            <span class="n">energ</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">inverse_rescale</span><span class="p">(</span><span class="n">energ</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">set_delay</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">abort</span><span class="p">):</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">energ</span><span class="p">,</span> <span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">mean</span><span class="o">.</span><span class="n">var</span><span class="p">(),</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">()</span>

</div>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">scell</span><span class="o">=</span><span class="s">&#39;$0/scell&#39;</span><span class="p">,</span> <span class="n">init_adens</span><span class="o">=</span><span class="s">&#39;$0/adens&#39;</span><span class="p">,</span>
                 <span class="n">init_avar</span><span class="o">=</span><span class="s">&#39;$0/avar&#39;</span><span class="p">,</span> <span class="n">init_acount</span><span class="o">=</span><span class="s">&#39;$0/acount&#39;</span><span class="p">,</span>
                 <span class="n">init_gdens</span><span class="o">=</span><span class="s">&#39;$0/gdens&#39;</span><span class="p">,</span>
                 <span class="n">init_gvar</span><span class="o">=</span><span class="s">&#39;$0/gvar&#39;</span><span class="p">,</span> <span class="n">init_gcount</span><span class="o">=</span><span class="s">&#39;$0/gcount&#39;</span><span class="p">),</span>
      <span class="n">outmap</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;$0/alenerg&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;$0/aldens&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#39;$0/alvar&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">&#39;$0/alcount&#39;</span><span class="p">,</span>
              <span class="mi">4</span><span class="p">:</span> <span class="s">&#39;$0/alacc&#39;</span><span class="p">,</span>
              <span class="mi">5</span><span class="p">:</span> <span class="s">&#39;$0/glenerg&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="s">&#39;$0/gldens&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="s">&#39;$0/glvar&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="s">&#39;$0/glcount&#39;</span><span class="p">,</span>
              <span class="mi">9</span><span class="p">:</span> <span class="s">&#39;$0/glacc&#39;</span><span class="p">},</span>
      <span class="n">opttypes</span><span class="o">=</span><span class="n">opttypes</span><span class="p">,</span> <span class="n">longopts</span><span class="o">=</span><span class="n">longopts</span><span class="p">,</span> <span class="n">shortopts</span><span class="o">=</span><span class="n">shortopts</span><span class="p">,</span>
      <span class="n">optdoc</span><span class="o">=</span><span class="n">optdoc</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<div class="viewcode-block" id="galdos"><a class="viewcode-back" href="../index.html#kpm.galdos">[docs]</a><span class="k">def</span> <span class="nf">galdos</span><span class="p">(</span><span class="n">scell</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
           <span class="n">smooth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;jackson&#39;</span><span class="p">,</span> <span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;std&#39;</span><span class="p">,</span>
           <span class="n">stateclass</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">spr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
           <span class="n">until</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
           <span class="n">init_adens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_avar</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_acount</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
           <span class="n">init_gdens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_gvar</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_gcount</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate both the geometric (typical average) and the arithmetic mean</span>
<span class="sd">    of the local density of states (GLDOS and ALDOS) at the same time, using</span>
<span class="sd">    each local density twice.  In this way, the numerical effort is easily</span>
<span class="sd">    reduced by a factor of 2 if both types of averages are needed.&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-24 until 2013-07-29</span>
    <span class="c"># based on tb2.kpm.gldos (developed 2013-07-24 until 2013-07-24)</span>
    <span class="c"># based on tb2.kpm.aldos (developed 2013-07-22 until 2013-07-24)</span>
    <span class="c"># based on tb.kpm2._aldos (developed 2012-09-03 until 2013-06-20)</span>
    <span class="c"># based on tb.kpm._Ados (developed from 2012-04-26 until 2012-07-16) and</span>
    <span class="c">#          tb.kpm._Gdos (developed from 2011-12-20 until 2012-07-17)</span>
    <span class="c"># based on tb.kpm._Gdos from 2011-12-20 until 2012-04-18</span>

    <span class="c">### compare complete parameter sets? warn when continuing calculation?</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="ow">and</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;count&quot; or &quot;tol&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enum</span> <span class="ow">and</span> <span class="n">estep</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">enum</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">estep</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;enum&quot; or &quot;estep&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init_adens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">init_avar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> \
            <span class="o">+</span> <span class="p">(</span><span class="n">init_acount</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;either all 3 init values have to be given or none &#39;</span> <span class="o">+</span>
                         <span class="s">&#39;at all&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init_gdens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">init_gvar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> \
            <span class="o">+</span> <span class="p">(</span><span class="n">init_gcount</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;either all 3 init values have to be given or none &#39;</span> <span class="o">+</span>
                         <span class="s">&#39;at all&#39;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">progress</span><span class="o">.</span><span class="n">Abort</span><span class="p">()</span> <span class="k">as</span> <span class="n">abort</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Converge</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span> <span class="k">as</span> <span class="n">aconverge</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Converge</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span> <span class="k">as</span> <span class="n">gconverge</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Until</span><span class="p">(</span><span class="n">until</span><span class="p">)</span> <span class="k">as</span> <span class="n">until</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Terminate</span><span class="p">()</span> <span class="k">as</span> <span class="n">term</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Monitor</span><span class="p">(</span><span class="n">formats</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">aacc</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%g</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">gacc</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%g</span><span class="s">&#39;</span><span class="p">),</span>
                         <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;smooth&#39;</span><span class="p">,</span> <span class="s">&#39;acount&#39;</span><span class="p">,</span> <span class="s">&#39;aacc&#39;</span><span class="p">,</span> <span class="s">&#39;gcount&#39;</span><span class="p">,</span> <span class="s">&#39;gacc&#39;</span><span class="p">],</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">tol</span><span class="p">))</span> <span class="k">as</span> <span class="n">mon</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;calculate ALDOS and GLDOS&#39;</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">count</span><span class="p">))</span> <span class="k">as</span> <span class="n">bar</span><span class="p">:</span>

        <span class="c"># as soon as the matrix has been rescaled for the first time and a</span>
        <span class="c"># rescaled energy array is retrieved from the core module, set this</span>
        <span class="c"># to True</span>
        <span class="c"># so this is True when at least one for-loop iteration has been done</span>
        <span class="n">scaleback</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">amean</span> <span class="o">=</span> <span class="n">oalg</span><span class="o">.</span><span class="n">Mean</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">init_adens</span><span class="p">,</span> <span class="n">init_count</span><span class="o">=</span><span class="n">init_acount</span><span class="p">,</span>
                          <span class="n">init_var</span><span class="o">=</span><span class="n">init_avar</span><span class="p">)</span>
        <span class="n">gmean</span> <span class="o">=</span> <span class="n">oalg</span><span class="o">.</span><span class="n">gMean</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">init_gdens</span><span class="p">,</span> <span class="n">init_count</span><span class="o">=</span><span class="n">init_gcount</span><span class="p">,</span>
                           <span class="n">init_var</span><span class="o">=</span><span class="n">init_gvar</span><span class="p">)</span>

        <span class="c"># the progress bar may jump ahead if a fixed sample size is given</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">amean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">gmean</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>

        <span class="c">#size = scell.size()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">energ</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># cycle realizations</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tol</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">aconverge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">amean</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
                     <span class="ow">or</span> <span class="ow">not</span> <span class="n">gconverge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gmean</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">count</span> <span class="ow">or</span> <span class="n">amean</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="ow">or</span> <span class="n">gmean</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">mat</span><span class="p">,</span> <span class="n">stateclasses</span> <span class="o">=</span> <span class="n">scell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">(</span><span class="n">distinguish</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">_get_stateclass</span><span class="p">(</span><span class="n">stateclass</span><span class="p">,</span> <span class="n">stateclasses</span><span class="p">)</span>
            <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
            <span class="c">#erange = get_erange(erange, mat)</span>
            <span class="n">mat</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="n">erange</span><span class="p">,</span>
                                       <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                                       <span class="c">### copy=False not working???</span>
            <span class="n">estep2</span> <span class="o">=</span> <span class="n">estep</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">estep</span> <span class="k">else</span> <span class="bp">None</span>

            <span class="c"># cycle states</span>
            <span class="k">for</span> <span class="n">sind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">spr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">or</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">or</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                    <span class="ow">or</span> <span class="p">(</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">aconverge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">amean</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
                        <span class="ow">and</span> <span class="n">gconverge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">gmean</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> \
                    <span class="ow">or</span> <span class="p">(</span><span class="n">count</span> <span class="ow">and</span> <span class="n">amean</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">count</span>
                        <span class="ow">and</span> <span class="n">gmean</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">count</span><span class="p">):</span>
                    <span class="k">break</span>

                <span class="c"># calculate LDOS</span>
                <span class="c"># erange isn&#39;t needed if rescaled is True</span>
                <span class="n">energ</span><span class="p">,</span> <span class="n">dens</span> <span class="o">=</span> <span class="n">ldos</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">rescaled</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                   <span class="n">rcstr_method</span><span class="o">=</span><span class="n">rcstr_method</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="n">enum</span><span class="p">,</span>
                                   <span class="n">estep</span><span class="o">=</span><span class="n">estep2</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
                                   <span class="n">state</span><span class="o">=</span><span class="n">inds</span><span class="p">[</span><span class="n">sind</span><span class="p">],</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                <span class="n">scaleback</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">rdens</span> <span class="o">=</span> <span class="n">dens</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">amean</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rdens</span><span class="p">)</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
                <span class="n">gmean</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rdens</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>  <span class="c"># because sometimes small negative</span>
                                            <span class="c"># values occur</span>

                <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">acount</span><span class="o">=</span><span class="n">amean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
                           <span class="n">aacc</span><span class="o">=</span><span class="n">aconverge</span><span class="o">.</span><span class="n">delta</span><span class="p">(),</span>
                           <span class="n">gcount</span><span class="o">=</span><span class="n">gmean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">gacc</span><span class="o">=</span><span class="n">gconverge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>
                <span class="n">bar</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">scaleback</span><span class="p">:</span>
            <span class="n">energ</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">inverse_rescale</span><span class="p">(</span><span class="n">energ</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">set_delay</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">acount</span><span class="o">=</span><span class="n">amean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">aacc</span><span class="o">=</span><span class="n">aconverge</span><span class="o">.</span><span class="n">delta</span><span class="p">(),</span>
                   <span class="n">gcount</span><span class="o">=</span><span class="n">gmean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">gacc</span><span class="o">=</span><span class="n">gconverge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">abort</span><span class="p">):</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">energ</span><span class="p">,</span> <span class="n">amean</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">amean</span><span class="o">.</span><span class="n">var</span><span class="p">(),</span> <span class="n">amean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">aconverge</span><span class="o">.</span><span class="n">delta</span><span class="p">(),</span> \
        <span class="n">energ</span><span class="p">,</span> <span class="n">gmean</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">gmean</span><span class="o">.</span><span class="n">var</span><span class="p">(),</span> <span class="n">gmean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">gconverge</span><span class="o">.</span><span class="n">delta</span><span class="p">()</span>

</div>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="s">&#39;$0/scell&#39;</span><span class="p">),</span>
      <span class="n">preproc</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">mat</span><span class="o">=</span><span class="k">lambda</span> <span class="n">scell</span><span class="p">:</span> <span class="n">scell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&#39;csr&#39;</span><span class="p">)),</span>
      <span class="n">outmap</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;$0/energ&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;$0/dens&#39;</span><span class="p">},</span>
      <span class="n">opttypes</span><span class="o">=</span><span class="n">opttypes</span><span class="p">,</span> <span class="n">longopts</span><span class="o">=</span><span class="n">longopts</span><span class="p">,</span> <span class="n">shortopts</span><span class="o">=</span><span class="n">shortopts</span><span class="p">,</span>
      <span class="n">optdoc</span><span class="o">=</span><span class="n">optdoc</span><span class="p">)</span>
<div class="viewcode-block" id="dos"><a class="viewcode-back" href="../index.html#kpm.dos">[docs]</a><span class="k">def</span> <span class="nf">dos</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">rcount</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rsmooth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">enum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;jackson&#39;</span><span class="p">,</span> <span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;std&#39;</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rescaled</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate density of states (DOS) using &quot;stochastic evaluation of</span>
<span class="sd">    traces&quot;.</span>

<span class="sd">    Note that there is no ensemble averaging. Use the function ados to include</span>
<span class="sd">    an average over different disorder configurations if a random system is</span>
<span class="sd">    studied.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rcount</span> <span class="ow">and</span> <span class="n">rtol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">rcount</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rtol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;rcount&quot; or &quot;rtol&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enum</span> <span class="ow">and</span> <span class="n">estep</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">enum</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">estep</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;enum&quot; or &quot;estep&quot; must be given&#39;</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">)</span> \
        <span class="k">else</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expecting square matrix&#39;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">erange</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">rescaled</span> <span class="k">else</span> <span class="n">misc</span><span class="o">.</span><span class="n">symmetric_interval</span><span class="p">(</span><span class="n">erange</span><span class="p">)</span>
    <span class="n">mat</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="n">erange</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                               <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span> \
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rescaled</span> <span class="k">else</span> <span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span>
    <span class="n">rcstr_func</span> <span class="o">=</span> <span class="n">rcstr</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">rcstr_method</span><span class="p">)</span>
    <span class="n">kernel_func</span> <span class="o">=</span> <span class="n">kern</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">energ</span> <span class="o">=</span> <span class="n">_get_energ</span><span class="p">(</span><span class="n">rcstr_func</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span> <span class="n">estep</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">rcstr_args</span><span class="p">,</span> <span class="n">rcstr_kwargs</span> <span class="o">=</span> <span class="n">_get_rcstr_args</span><span class="p">(</span><span class="n">rcstr_func</span><span class="p">,</span> <span class="n">energ</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span>
                                               <span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">progress</span><span class="o">.</span><span class="n">Abort</span><span class="p">()</span> <span class="k">as</span> <span class="n">abort</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Converge</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">rsmooth</span><span class="p">)</span> <span class="k">as</span> <span class="n">converge</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Until</span><span class="p">(</span><span class="n">until</span><span class="p">)</span> <span class="k">as</span> <span class="n">until</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Terminate</span><span class="p">()</span> <span class="k">as</span> <span class="n">term</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Monitor</span><span class="p">(</span><span class="n">formats</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">acc</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%g</span><span class="s">&#39;</span><span class="p">),</span>
                         <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;smooth&#39;</span><span class="p">,</span> <span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="s">&#39;acc&#39;</span><span class="p">],</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">rtol</span><span class="p">))</span> <span class="k">as</span> <span class="n">mon</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span><span class="n">rcount</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;calculate DOS&#39;</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">rcount</span><span class="p">))</span> <span class="k">as</span> <span class="n">bar</span><span class="p">:</span>

        <span class="n">mean</span> <span class="o">=</span> <span class="n">oalg</span><span class="o">.</span><span class="n">Mean</span><span class="p">()</span>

        <span class="c"># cycle random-phase start vectors</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">rtol</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">converge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">rcount</span> <span class="ow">or</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">rcount</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">svect</span><span class="o">.</span><span class="n">randphase</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>  <span class="c"># dtype=complex</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">mom</span><span class="o">.</span><span class="n">expec</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
            <span class="n">mean</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

            <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">rsmooth</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="n">moments</span> <span class="o">=</span> <span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c"># / rank  # or not?</span>
        <span class="n">kernel_func</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">moments</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">rcstr_func</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="o">*</span><span class="n">rcstr_args</span><span class="p">,</span> <span class="o">**</span><span class="n">rcstr_kwargs</span><span class="p">)</span>
        <span class="n">energ</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">inverse_rescale</span><span class="p">(</span><span class="n">energ</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>

        <span class="c"># WTF, let&#39;s normalize the DOS by hand...</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">dens</span><span class="p">,</span> <span class="n">energ</span><span class="p">)</span>
        <span class="c">#print area</span>
        <span class="n">dens</span> <span class="o">/=</span> <span class="n">area</span>
        <span class="c">#print numpy.trapz(dens, energ)</span>

        <span class="n">mon</span><span class="o">.</span><span class="n">set_delay</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">rsmooth</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">abort</span><span class="p">):</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">energ</span><span class="p">,</span> <span class="n">dens</span>  <span class="c"># how to propagate error?</span>

</div>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">scell</span><span class="o">=</span><span class="s">&#39;$0/scell&#39;</span><span class="p">,</span> <span class="n">init_dens</span><span class="o">=</span><span class="s">&#39;$0/adens&#39;</span><span class="p">,</span> <span class="n">init_var</span><span class="o">=</span><span class="s">&#39;$0/avar&#39;</span><span class="p">,</span>
                 <span class="n">init_count</span><span class="o">=</span><span class="s">&#39;$0/acount&#39;</span><span class="p">),</span>
      <span class="n">outmap</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s">&#39;$0/aenerg&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&#39;$0/adens&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&#39;$0/avar&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s">&#39;$0/acount&#39;</span><span class="p">,</span>
              <span class="mi">4</span><span class="p">:</span> <span class="s">&#39;$0/aacc&#39;</span><span class="p">},</span>
      <span class="n">opttypes</span><span class="o">=</span><span class="n">opttypes</span><span class="p">,</span> <span class="n">longopts</span><span class="o">=</span><span class="n">longopts</span><span class="p">,</span> <span class="n">shortopts</span><span class="o">=</span><span class="n">shortopts</span><span class="p">,</span>
      <span class="n">optdoc</span><span class="o">=</span><span class="n">optdoc</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<div class="viewcode-block" id="ados"><a class="viewcode-back" href="../index.html#kpm.ados">[docs]</a><span class="k">def</span> <span class="nf">ados</span><span class="p">(</span><span class="n">scell</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">estep</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
         <span class="n">smooth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">rcount</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rsmooth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
         <span class="n">kernel</span><span class="o">=</span><span class="s">&#39;jackson&#39;</span><span class="p">,</span> <span class="n">rcstr_method</span><span class="o">=</span><span class="s">&#39;std&#39;</span><span class="p">,</span> <span class="n">omp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
         <span class="n">until</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
         <span class="n">init_dens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_var</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">init_count</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate arithmetic mean of density of states (ADOS) (ensemble</span>
<span class="sd">    average).&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-13</span>

    <span class="c">### compare complete parameter sets? warn when continuing calculation?</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="ow">and</span> <span class="n">tol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;count&quot; or &quot;tol&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enum</span> <span class="ow">and</span> <span class="n">estep</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">enum</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">estep</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;exactly one of &quot;enum&quot; or &quot;estep&quot; must be given&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">init_dens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">init_var</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> \
            <span class="o">+</span> <span class="p">(</span><span class="n">init_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;either all 3 init values have to be given or &#39;</span> <span class="o">+</span>
                         <span class="s">&#39;none at all&#39;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">progress</span><span class="o">.</span><span class="n">Abort</span><span class="p">()</span> <span class="k">as</span> <span class="n">abort</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Converge</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span> <span class="k">as</span> <span class="n">converge</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Until</span><span class="p">(</span><span class="n">until</span><span class="p">)</span> <span class="k">as</span> <span class="n">until</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Terminate</span><span class="p">()</span> <span class="k">as</span> <span class="n">term</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Monitor</span><span class="p">(</span><span class="n">formats</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">acc</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%g</span><span class="s">&#39;</span><span class="p">),</span>
                         <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;smooth&#39;</span><span class="p">,</span> <span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="s">&#39;acc&#39;</span><span class="p">],</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">tol</span><span class="p">))</span> <span class="k">as</span> <span class="n">mon</span><span class="p">,</span> \
        <span class="n">progress</span><span class="o">.</span><span class="n">Bar</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s">&#39;calculate ADOS&#39;</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="o">=</span><span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">count</span><span class="p">))</span> <span class="k">as</span> <span class="n">bar</span><span class="p">:</span>

        <span class="c"># as soon as the matrix has been rescaled for the first time and a</span>
        <span class="c"># rescaled energy array is retrieved from the core module, set this</span>
        <span class="c"># to True</span>
        <span class="c"># so this is True when at least one for-loop iteration has been done</span>
        <span class="n">scaleback</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">oalg</span><span class="o">.</span><span class="n">Mean</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">init_dens</span><span class="p">,</span> <span class="n">init_count</span><span class="o">=</span><span class="n">init_count</span><span class="p">,</span>
                         <span class="n">init_var</span><span class="o">=</span><span class="n">init_var</span><span class="p">)</span>

        <span class="c"># the progress bar may jump ahead if a fixed sample size is given</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">jump</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>

        <span class="c">#size = scell.size()</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="n">energ</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># cycle realizations</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">until</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">abort</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tol</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">converge</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">count</span> <span class="ow">or</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">scell</span><span class="o">.</span><span class="n">tbmat</span><span class="p">()</span>
            <span class="c">#erange = get_erange(erange, mat)</span>
            <span class="n">mat</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">rescale</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">erange</span><span class="o">=</span><span class="n">erange</span><span class="p">,</span>
                                       <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                                       <span class="c">### copy=False not working???</span>
            <span class="n">estep2</span> <span class="o">=</span> <span class="n">estep</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">estep</span> <span class="k">else</span> <span class="bp">None</span>

            <span class="c"># calculate LDOS</span>
            <span class="c"># erange isn&#39;t needed if rescaled is True</span>
            <span class="n">energ</span><span class="p">,</span> <span class="n">dens</span> <span class="o">=</span> <span class="n">dos</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">rescaled</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                              <span class="n">rcstr_method</span><span class="o">=</span><span class="n">rcstr_method</span><span class="p">,</span> <span class="n">enum</span><span class="o">=</span><span class="n">enum</span><span class="p">,</span>
                              <span class="n">estep</span><span class="o">=</span><span class="n">estep2</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">,</span>
                              <span class="n">rcount</span><span class="o">=</span><span class="n">rcount</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">rsmooth</span><span class="o">=</span><span class="n">rsmooth</span><span class="p">,</span>
                              <span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
            <span class="n">scaleback</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">mean</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dens</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>
            <span class="n">bar</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">scaleback</span><span class="p">:</span>
            <span class="n">energ</span> <span class="o">=</span> <span class="n">resc</span><span class="o">.</span><span class="n">inverse_rescale</span><span class="p">(</span><span class="n">energ</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">set_delay</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mon</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="p">(</span><span class="n">until</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">abort</span><span class="p">):</span>
        <span class="n">handler</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">energ</span><span class="p">,</span> <span class="n">mean</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">mean</span><span class="o">.</span><span class="n">var</span><span class="p">(),</span> <span class="n">mean</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">converge</span><span class="o">.</span><span class="n">delta</span><span class="p">()</span>


<span class="c">#===============================================================#</span>
<span class="c"># Helper functions to get count or accuracy from GLDOS or ALDOS #</span>
<span class="c">#===============================================================#</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="glcount"><a class="viewcode-back" href="../index.html#kpm.glcount">[docs]</a><span class="k">def</span> <span class="nf">glcount</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``gldos.attrs.count`` of the dataset ``gldos`` from</span>
<span class="sd">    the given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/gldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="alcount"><a class="viewcode-back" href="../index.html#kpm.alcount">[docs]</a><span class="k">def</span> <span class="nf">alcount</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``aldos.attrs.count`` of the dataset ``aldos`` from</span>
<span class="sd">    the given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/aldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="glacc"><a class="viewcode-back" href="../index.html#kpm.glacc">[docs]</a><span class="k">def</span> <span class="nf">glacc</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``gldos.attrs.acc`` of the dataset ``gldos`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/gldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">acc</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="alacc"><a class="viewcode-back" href="../index.html#kpm.alacc">[docs]</a><span class="k">def</span> <span class="nf">alacc</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``aldos.attrs.acc`` of the dataset ``aldos`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2013-07-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/aldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">acc</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="gllimit"><a class="viewcode-back" href="../index.html#kpm.gllimit">[docs]</a><span class="k">def</span> <span class="nf">gllimit</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``gldos.attrs.limit`` of the dataset ``gldos`` from</span>
<span class="sd">    the given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-07</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/gldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">limit</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="allimit"><a class="viewcode-back" href="../index.html#kpm.allimit">[docs]</a><span class="k">def</span> <span class="nf">allimit</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``aldos.attrs.limit`` of the dataset ``aldos`` from</span>
<span class="sd">    the given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/aldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">limit</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="acount"><a class="viewcode-back" href="../index.html#kpm.acount">[docs]</a><span class="k">def</span> <span class="nf">acount</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``ados.attrs.count`` of the dataset ``ados`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/ados&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="aacc"><a class="viewcode-back" href="../index.html#kpm.aacc">[docs]</a><span class="k">def</span> <span class="nf">aacc</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``ados.attrs.acc`` of the dataset ``ados`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/ados&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">acc</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="alimit"><a class="viewcode-back" href="../index.html#kpm.alimit">[docs]</a><span class="k">def</span> <span class="nf">alimit</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``ados.attrs.limit`` of the dataset ``ados`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/ados&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">limit</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="lcount"><a class="viewcode-back" href="../index.html#kpm.lcount">[docs]</a><span class="k">def</span> <span class="nf">lcount</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``ldos.attrs.count`` of the dataset ``ldos`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/ldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="lacc"><a class="viewcode-back" href="../index.html#kpm.lacc">[docs]</a><span class="k">def</span> <span class="nf">lacc</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``ldos.attrs.acc`` of the dataset ``ldos`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/ldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">acc</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="llimit"><a class="viewcode-back" href="../index.html#kpm.llimit">[docs]</a><span class="k">def</span> <span class="nf">llimit</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``ldos.attrs.limit`` of the dataset ``ldos`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/ldos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">limit</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="dcount"><a class="viewcode-back" href="../index.html#kpm.dcount">[docs]</a><span class="k">def</span> <span class="nf">dcount</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``dos.attrs.count`` of the dataset ``dos`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/dos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="dacc"><a class="viewcode-back" href="../index.html#kpm.dacc">[docs]</a><span class="k">def</span> <span class="nf">dacc</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``dos.attrs.acc`` of the dataset ``dos`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/dos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">acc</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="dlimit"><a class="viewcode-back" href="../index.html#kpm.dlimit">[docs]</a><span class="k">def</span> <span class="nf">dlimit</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the attribute ``dos.attrs.limit`` of the dataset ``dos`` from the</span>
<span class="sd">    given HDF5 file.&quot;&quot;&quot;</span>
    <span class="c"># 2014-01-14</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;/dos&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">limit</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="glstderr0"><a class="viewcode-back" href="../index.html#kpm.glstderr0">[docs]</a><span class="k">def</span> <span class="nf">glstderr0</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the standard error of the GLDOS at zero energy.&quot;&quot;&quot;</span>
    <span class="c"># 2014-02-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">gldos</span> <span class="o">=</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;/gldos&#39;</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">gldos</span><span class="o">.</span><span class="n">a2cf</span><span class="p">(</span><span class="s">&#39;var&#39;</span><span class="p">)</span>
        <span class="n">var0</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">gldos</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
        <span class="n">stderr0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var0</span><span class="o">/</span><span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">stderr0</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="alstderr0"><a class="viewcode-back" href="../index.html#kpm.alstderr0">[docs]</a><span class="k">def</span> <span class="nf">alstderr0</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the standard error of the ALDOS at zero energy.&quot;&quot;&quot;</span>
    <span class="c"># 2014-02-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">aldos</span> <span class="o">=</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;/aldos&#39;</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">aldos</span><span class="o">.</span><span class="n">a2cf</span><span class="p">(</span><span class="s">&#39;var&#39;</span><span class="p">)</span>
        <span class="n">var0</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">aldos</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
        <span class="n">stderr0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var0</span><span class="o">/</span><span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">stderr0</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="astderr0"><a class="viewcode-back" href="../index.html#kpm.astderr0">[docs]</a><span class="k">def</span> <span class="nf">astderr0</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the standard error of the ADOS at zero energy.&quot;&quot;&quot;</span>
    <span class="c"># 2014-02-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ados</span> <span class="o">=</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;/ados&#39;</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">ados</span><span class="o">.</span><span class="n">a2cf</span><span class="p">(</span><span class="s">&#39;var&#39;</span><span class="p">)</span>
        <span class="n">var0</span> <span class="o">=</span> <span class="n">var</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">ados</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
        <span class="n">stderr0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var0</span><span class="o">/</span><span class="p">(</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">stderr0</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">(</span><span class="n">inmap</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">gldos_list</span><span class="o">=</span><span class="s">&#39;$@/gldos&#39;</span><span class="p">,</span> <span class="n">aldos_list</span><span class="o">=</span><span class="s">&#39;$@/aldos&#39;</span><span class="p">))</span>
<div class="viewcode-block" id="checksigma"><a class="viewcode-back" href="../index.html#kpm.checksigma">[docs]</a><span class="k">def</span> <span class="nf">checksigma</span><span class="p">(</span><span class="n">gldos_list</span><span class="p">,</span> <span class="n">aldos_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Investigate the fluctuation of the standard error of the geometric mean</span>
<span class="sd">    among independent calculations.&quot;&quot;&quot;</span>
    <span class="c"># 2014-02-28</span>
    <span class="n">gvals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">avals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gstderrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">astderrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gammavals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gammastds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">print</span>
    <span class="k">print</span> <span class="s">&#39;GLDOS                ALDOS                Gamma&#39;</span>
    <span class="k">for</span> <span class="n">gldos</span><span class="p">,</span> <span class="n">aldos</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gldos_list</span><span class="p">,</span> <span class="n">aldos_list</span><span class="p">):</span>
        <span class="n">gldos0val</span> <span class="o">=</span> <span class="n">gldos</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">aldos0val</span> <span class="o">=</span> <span class="n">aldos</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">gvar</span> <span class="o">=</span> <span class="n">gldos</span><span class="o">.</span><span class="n">a2cf</span><span class="p">(</span><span class="s">&#39;var&#39;</span><span class="p">)</span>
        <span class="n">avar</span> <span class="o">=</span> <span class="n">aldos</span><span class="o">.</span><span class="n">a2cf</span><span class="p">(</span><span class="s">&#39;var&#39;</span><span class="p">)</span>
        <span class="n">gldos0var</span> <span class="o">=</span> <span class="n">gvar</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">aldos0var</span> <span class="o">=</span> <span class="n">avar</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">gcount</span> <span class="o">=</span> <span class="n">gldos</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
        <span class="n">acount</span> <span class="o">=</span> <span class="n">aldos</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">count</span>
        <span class="n">gldos0stderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gldos0var</span><span class="o">/</span><span class="p">(</span><span class="n">gcount</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">aldos0stderr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">aldos0var</span><span class="o">/</span><span class="p">(</span><span class="n">acount</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">gvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gldos0val</span><span class="p">)</span>
        <span class="n">avals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aldos0val</span><span class="p">)</span>
        <span class="n">gstderrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gldos0stderr</span><span class="p">)</span>
        <span class="n">astderrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aldos0stderr</span><span class="p">)</span>

        <span class="c"># calculate gamma</span>
        <span class="n">gamma0val</span> <span class="o">=</span> <span class="n">gldos0val</span> <span class="o">/</span> <span class="n">aldos0val</span>
        <span class="n">gamma0std</span> <span class="o">=</span> <span class="n">gldos0stderr</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">aldos0val</span><span class="p">)</span> \
            <span class="o">+</span> <span class="n">aldos0stderr</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">gldos0val</span><span class="o">/</span><span class="n">aldos0val</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c">#gamma0var = gamma0std**2</span>
        <span class="n">gammavals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gamma0val</span><span class="p">)</span>
        <span class="n">gammastds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gamma0std</span><span class="p">)</span>

        <span class="k">print</span> <span class="s">&#39;</span><span class="si">%.7f</span><span class="s">+-</span><span class="si">%.7f</span><span class="s"> </span><span class="si">%.7f</span><span class="s">+-</span><span class="si">%.7f</span><span class="s"> </span><span class="si">%.7f</span><span class="s">+-</span><span class="si">%.7f</span><span class="s">&#39;</span> \
            <span class="o">%</span> <span class="p">(</span><span class="n">gldos0val</span><span class="p">,</span> <span class="n">gldos0stderr</span><span class="p">,</span> <span class="n">aldos0val</span><span class="p">,</span> <span class="n">aldos0stderr</span><span class="p">,</span>
               <span class="n">gamma0val</span><span class="p">,</span> <span class="n">gamma0std</span><span class="p">)</span>

    <span class="c"># compare with standard deviation</span>
    <span class="n">gst</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">gvals</span><span class="p">)</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">avals</span><span class="p">)</span>
    <span class="n">gammast</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">gammavals</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;STD: </span><span class="si">%.7f</span><span class="s">            </span><span class="si">%.7f</span><span class="s">            </span><span class="si">%.7f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">gst</span><span class="p">,</span> <span class="n">ast</span><span class="p">,</span> <span class="n">gammast</span><span class="p">)</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="glval0"><a class="viewcode-back" href="../index.html#kpm.glval0">[docs]</a><span class="k">def</span> <span class="nf">glval0</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the GLDOS at zero energy.&quot;&quot;&quot;</span>
    <span class="c"># 2014-02-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">gldos</span> <span class="o">=</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;/gldos&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gldos</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="alval0"><a class="viewcode-back" href="../index.html#kpm.alval0">[docs]</a><span class="k">def</span> <span class="nf">alval0</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the ALDOS at zero energy.&quot;&quot;&quot;</span>
    <span class="c"># 2014-02-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">aldos</span> <span class="o">=</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;/aldos&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aldos</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<span class="nd">@Frog</span><span class="p">()</span>
<div class="viewcode-block" id="aval0"><a class="viewcode-back" href="../index.html#kpm.aval0">[docs]</a><span class="k">def</span> <span class="nf">aval0</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the ADOS at zero energy.&quot;&quot;&quot;</span>
    <span class="c"># 2014-02-28</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ados</span> <span class="o">=</span> <span class="n">h5obj</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">h5load</span><span class="p">(</span><span class="n">filename</span><span class="o">+</span><span class="s">&#39;/ados&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ados</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>


<span class="c">#class _ldos_many(_ldos):</span>
  <span class="c">#&quot;&quot;&quot;Calculate local density of states (LDOS) using the kernel polynomial</span>
  <span class="c">#method (KPM) [1] for many truncation limits at once.</span>

  <span class="c">#[1] Weisse et al., Rev. Mod. Phys. 78, 275 (2006)&quot;&quot;&quot;</span>
  <span class="c">#__created__ = &#39;2013-05-31&#39;</span>
  <span class="c">#__modified__ = &#39;2013-06-19&#39;</span>
  <span class="c">#outnames = [&#39;densities&#39;]</span>

  <span class="c">#def main(self):</span>
    <span class="c">## get matrix</span>
    <span class="c">#if isinstance(self.infile.__scell__, tb.sc.SuperCell):</span>
      <span class="c">#mat, stateclasses = self.infile.__scell__.tbmat(distinguish=True)</span>
      <span class="c">#mat = mat.tocsr()</span>
      <span class="c">#inds = self.get_stateclass(self.opts.stateclass, stateclasses)</span>
      <span class="c">#size = self.infile.__scell__.size()</span>
    <span class="c">#elif isinstance(self.infile.__scell__, scipy.sparse.base.spmatrix):</span>
      <span class="c">#mat = self.infile.__scell__.tocsr()</span>
      <span class="c">#inds = None</span>
      <span class="c">#size = None # use rank of the matrix?</span>
    <span class="c">#else:</span>
      <span class="c">## maybe a dense matrix is given?</span>
      <span class="c">#mat = scipy.sparse.csr_matrix(self.infile.__scell__)</span>
      <span class="c">#inds = None</span>
      <span class="c">#size = None # use rank of the matrix?</span>

    <span class="c">## get matrix dimensions (assume square matrix)</span>
    <span class="c">#if mat.ndim != 2 or mat.shape[0] != mat.shape[1]:</span>
      <span class="c">#raise ValueError, &#39;bad matrix: expecting square matrix, not %ix%i&#39; \</span>
                        <span class="c">#% mat.shape</span>
    <span class="c">#rank = mat.shape[0]</span>
    <span class="c">#if inds is None:</span>
      <span class="c">#inds = range(rank)</span>

    <span class="c">## select states</span>
    <span class="c">#states = self.get_states(self.opts.state, inds)</span>

    <span class="c">## get truncation limits</span>
    <span class="c">#limits = self.get_limits(self.opts.limit, size)</span>

    <span class="c">## get energy range</span>
    <span class="c">#erange = self.get_erange(self.opts.erange, mat)</span>

    <span class="c">## determine energy range and rescale hamiltonian matrix</span>
    <span class="c">#mat, params = resc.rescale(mat, erange=erange, copy=True,</span>
                               <span class="c">#omp=self.opts.omp) \</span>
                  <span class="c">#if not self.opts.rescaled else (mat, (1., 0.))</span>

    <span class="c">## select reconstruction method (only DCT or STD right now)</span>
    <span class="c">#selected_rcstr_method = rcstr.select(self.opts.rcstr, many=True)</span>

    <span class="c">## get number of intervals</span>
    <span class="c">##intervals = self.get_intervals(self.opts.intervals, limit, params)</span>
    <span class="c">#### for each it&#39;s own intervals?</span>

    <span class="c">## discretize energy axis</span>
    <span class="c">#if selected_rcstr_method is rcstr.dct_many:</span>
      <span class="c">#energ = disc.cosine(self.opts.intervals)</span>
    <span class="c">#elif selected_rcstr_method is rcstr.std_many:</span>
      <span class="c">#energ = disc.uniform(self.opts.intervals)</span>
    <span class="c">#else:</span>
      <span class="c">#print &gt;&gt;sys.stderr, &#39;ldos: unknown reconstruction method: %s&#39; \</span>
                          <span class="c">#% selected_rcstr_method</span>
      <span class="c">#return</span>

    <span class="c">## select keyword arguments for reconstruction algorithm</span>
    <span class="c">#rcstr_args = []</span>
    <span class="c">#rcstr_kwargs = dict(omp=self.opts.omp, limits=limits)</span>
    <span class="c">#if selected_rcstr_method is rcstr.std_many:</span>
      <span class="c">#rcstr_args.append(energ) # use uniform discretization in STD mode</span>
    <span class="c">#elif selected_rcstr_method is rcstr.dct_many:</span>
      <span class="c">#rcstr_kwargs[&#39;ndisc&#39;] = self.opts.intervals # pass number of intervals</span>

    <span class="c">## select kernel</span>
    <span class="c">#selected_kernel = kern.select(self.opts.kernel)</span>

    <span class="c">## cycle states, average over local densities</span>
    <span class="c">#means = [oalg.Mean() for limit in limits]</span>
    <span class="c">#bar = progress.Bar(len(states)*len(limits), verbose=self.opts.verbose)</span>
    <span class="c">#for state in states:</span>
      <span class="c">## create starting vector</span>
      <span class="c">#start = svect.ind(rank, state, dtype=mat.dtype)</span>

      <span class="c">## calculate Chebychev moments, apply kernel</span>
      <span class="c">#moments = mom.expec(mat, start, limit, omp=self.opts.omp)</span>
      <span class="c">#selected_kernel(moments, out=moments, omp=self.opts.omp)</span>

      <span class="c">## reconstruct target function (local density of states)</span>
      <span class="c">#denses = selected_rcstr_method(moments, *rcstr_args, **rcstr_kwargs)</span>

      <span class="c">## add data to online-averaging object</span>
      <span class="c">#for mean, dens in zip(means, denses):</span>
        <span class="c">#mean.add(dens.real/params[0])</span>
        <span class="c">#bar.step()</span>
    <span class="c">#bar.end()</span>

    <span class="c">## inverse-rescale energy axis</span>
    <span class="c">#energ = resc.inverse_rescale(energ, params)</span>

    <span class="c">## save result</span>
    <span class="c">#densities = []</span>
    <span class="c">#for mean, limit in zip(means, limits):</span>
      <span class="c">#ldos = cofunc.coFunc(energ, mean.mean())</span>
      <span class="c">#ldos.attrs.limit  = limit</span>
      <span class="c">#ldos.attrs.states = states</span>
      <span class="c">#ldos.attrs.count  = mean.count</span>
      <span class="c">#ldos.attrs.var    = mean.var()</span>
      <span class="c">#ldos.attrs.ci     = mean.ci()</span>
      <span class="c">#ldos.attrs.kernel = selected_kernel.__name__</span>
      <span class="c">#ldos.attrs.rcstr  = selected_rcstr_method.__name__</span>
      <span class="c">#ldos.attrs.erange = erange</span>
      <span class="c">#ldos.attrs.intervals = intervals*params[0] \</span>
                            <span class="c">#if isinstance(intervals, float) else intervals</span>
      <span class="c">#ldos.attrs.ndisc     = len(energ)</span>
      <span class="c">#densities.append(ldos)</span>
    <span class="c">#self.outfile.densities = densities</span>
    <span class="c">##self.outfile.limits    = limits</span>


<span class="c">#class _aldos_many(AveragingLDOS_KPMHDP00i):</span>
  <span class="c">#&quot;&quot;&quot;Calculate arithmetic mean of local density of states for many different</span>
  <span class="c">#truncation numbers at once.</span>

  <span class="c">#All results will be saved into the same file, named &quot;aldos100&quot;, &quot;aldos200&quot;,</span>
  <span class="c">#etc. according to the chosen truncation numbers.&quot;&quot;&quot;</span>
  <span class="c">#__created__ = &#39;2013-06-01&#39;</span>
  <span class="c">#__modified__ = &#39;2013-06-19&#39;</span>
  <span class="c">## based on tb.kpm2._aldos (developed 2012-09-03 until 2012-10-09)</span>
  <span class="c">## based on tb.kpm._Ados (developed from 2012-04-26 until 2012-07-16) and on</span>
  <span class="c">## tb.kpm._Gdos (developed from 2011-12-20 until 2012-07-17)</span>
  <span class="c">## based on tb.kpm._Gdos from 2011-12-20 until 2012-04-18</span>
  <span class="c">#innames = [&#39;__scell__&#39;]</span>
  <span class="c">#outnames = [] # names will be determined later (aldos100, aldos500, ...)</span>
  <span class="c">#__autoinst__ = True</span>

  <span class="c">#def prepare(self):</span>
    <span class="c">## get truncation limit</span>
    <span class="c">##size = self.infile.__scell__.size() # how to enable this?</span>
    <span class="c">#self.limits_from_option = self.get_limits(self.opts.limit) # size</span>

    <span class="c">## determine outnames</span>
    <span class="c">#self.outnames = [&#39;aldos%i&#39; % limit for limit in self.limits_from_option]</span>

  <span class="c">#def main(self):</span>
    <span class="c">## make sure a supercell definition is given</span>
    <span class="c">#if not isinstance(self.infile.__scell__, tb.sc.SuperCell):</span>
      <span class="c">#raise ValueError, &#39;expecting supercell definition&#39;</span>

    <span class="c">## instantiate LDOS HDP</span>
    <span class="c">#ldosfunc = _ldos_many()</span>

    <span class="c">## understand sample size option</span>
    <span class="c">#ssize, tol, digits = tb.misc.get_num_or_acc(self.opts.ssize)</span>

    <span class="c">## instantiate converge handlers</span>
    <span class="c">#converges = []</span>
    <span class="c">#for limit in self.limits_from_option:</span>
      <span class="c">#converges.append(progress.Converge(tol=tol, smooth=self.opts.smooth))</span>

    <span class="c">#with progress.Abort() as abort, \</span>
         <span class="c">#progress.Until(self.opts.until) as until, \</span>
         <span class="c">#progress.Terminate() as term, \</span>
         <span class="c">#progress.Monitor(formats=dict(max_acc=&#39;%.&#39;+str(digits)+&#39;f%%&#39;),</span>
                          <span class="c">#order=[&#39;min_count&#39;],</span>
                          <span class="c">#verbose=(self.opts.verbose and tol)) as mon, \</span>
         <span class="c">#progress.Bar(ssize, text=&#39;calculate ALDOS&#39;,</span>
                      <span class="c">#verbose=(self.opts.verbose and ssize)) as bar:</span>

      <span class="c">## as soon as the matrix has been rescaled for the first time and a</span>
      <span class="c">## rescaled energy array is retrieved from the core module, set this</span>
      <span class="c">## to True</span>
      <span class="c">## so basically this is True when at least one for-loop iteration has</span>
      <span class="c">## been done</span>
      <span class="c">#scaleback = False</span>

      <span class="c">## get previous results to continue calculation</span>
      <span class="c">#energs, denses, counts, accs, limits, eranges, vars, paramses \</span>
      <span class="c">#= [], [], [], [], [], [], [], []</span>
      <span class="c">#for outname in self.outnames:</span>
        <span class="c">#if outname in self.infile:</span>
          <span class="c">#energ  = self.infile[outname].x</span>
          <span class="c">#dens   = self.infile[outname].y</span>
          <span class="c">#count  = self.infile[outname].attrs.count</span>
          <span class="c">#acc    = self.infile[outname].attrs.acc</span>
          <span class="c">#limit  = self.infile[outname].attrs.limit</span>
          <span class="c">#erange = self.infile[outname].attrs.erange</span>
          <span class="c">#var    = self.infile[outname].attrs.var</span>
          <span class="c">##ci     = self.infile[outname].attrs.ci</span>
          <span class="c">#params = self.infile[outname].attrs.params</span>
        <span class="c">#else:</span>
          <span class="c">#energ  = None</span>
          <span class="c">#dens   = None</span>
          <span class="c">#count  = 0</span>
          <span class="c">#acc    = -1</span>
          <span class="c">#limit  = None</span>
          <span class="c">#erange = (None, None)</span>
          <span class="c">#var    = None</span>
          <span class="c">##ci     = None</span>
          <span class="c">#params = (None, None)</span>
        <span class="c">#energs.append(energ)</span>
        <span class="c">#denses.append(dens)</span>
        <span class="c">#counts.append(count)</span>
        <span class="c">#accs.append(acc)</span>
        <span class="c">#limits.append(limit)</span>
        <span class="c">#eranges.append(erange)</span>
        <span class="c">#vars.append(var)</span>
        <span class="c">#paramses.append(params)</span>

      <span class="c">## all energy ranges from the file have to be equal</span>
      <span class="c">#for erange in eranges[1:]:</span>
        <span class="c">#if eranges[0] != erange:</span>
          <span class="c">#raise ValueError, &#39;all energy ranges from the files must be equal&#39;</span>

      <span class="c">## get number of states per realizations of which the LDOS will be taken</span>
      <span class="c">## into account</span>
      <span class="c">#spr = self.get_spr(self.opts.spr, self.infile.__scell__)</span>

      <span class="c">## initialize geometric average calculators</span>
      <span class="c">#means = []</span>
      <span class="c">#for outname, dens, count, var in \</span>
      <span class="c">#zip(self.outnames, denses, counts, vars):</span>
        <span class="c">#means.append(oalg.Mean(init_value=dens, init_count=count,</span>
                               <span class="c">#init_var=var))</span>

      <span class="c">## the progress bar may jump ahead if a fixed sample size is given</span>
      <span class="c">#if ssize and not abort.check() and not term.check() \</span>
      <span class="c">#and not until.check():</span>
        <span class="c">#min_count = min([mean.count for mean in means])</span>
        <span class="c">#bar.jump(min_count)</span>

      <span class="c">## check truncation limit</span>
      <span class="c">#for lind in xrange(len(limits)):</span>
        <span class="c">#if limits[lind]:</span>
          <span class="c">#if self.limits_from_option[lind] != limits[lind]:</span>
            <span class="c">#raise ValueError, &#39;given truncation limit #%i&#39; % (lind+1)+\</span>
                              <span class="c">#&#39;(%i) is &#39; % limits_from_option[lind]+\</span>
                              <span class="c">#&#39;incompatible with the one from the data &#39;+\</span>
                              <span class="c">#&#39;file (%i)&#39; % limits[lind]</span>
        <span class="c">#else:</span>
          <span class="c">#limits[lind] = self.limits_from_option[lind]</span>

      <span class="c">## cycle realizations</span>
      <span class="c">#rcount = 0 # count realizations</span>
      <span class="c">#while not until.check() and not abort.check() \</span>
      <span class="c">#and not term.check():</span>

        <span class="c">## test if all converged or all have reached the requested sample size</span>
        <span class="c">#is_converged, count_reached = [], []</span>
        <span class="c">#for mean, converge in zip(means, converges):</span>
          <span class="c">#is_converged.append(converge.check(mean.mean()) if tol else False)</span>
          <span class="c">#count_reached.append(mean.count &gt;= ssize if ssize else False)</span>
        <span class="c">##print &#39;is_converged&#39;, is_converged, len(is_converged)</span>
        <span class="c">##print &#39;count_reached&#39;, count_reached, len(count_reached)</span>
        <span class="c">#if all(is_converged) or all(count_reached):</span>
          <span class="c">##print &#39;break1&#39;</span>
          <span class="c">#break</span>

        <span class="c">## get matrix of new disorder realization</span>
        <span class="c">#mat, stateclasses = self.infile.__scell__.tbmat(distinguish=True)</span>
        <span class="c">##print &#39;stateclass lengths:&#39;, str([len(sc) for sc in stateclasses])</span>
        <span class="c">#inds = self.get_stateclass(self.opts.stateclass, stateclasses)</span>
        <span class="c">##print self.opts.stateclass, inds</span>
        <span class="c">#random.shuffle(inds) ### IS THIS CORRECT?</span>
        <span class="c">#rcount += 1</span>

        <span class="c">## get energy range</span>
        <span class="c">#### as all eranges are checked equal earlier, we would actually just</span>
        <span class="c">#### need to compare with one of them</span>
        <span class="c">#erange_from_option = self.get_erange(self.opts.erange, mat)</span>
        <span class="c">#for erind, erange in enumerate(eranges):</span>
          <span class="c">#if erange[0] and erange[1]:</span>
            <span class="c">#if erange_from_option != erange:</span>
              <span class="c">#raise ValueError, &#39;given energy range &#39;+\</span>
                                <span class="c">#&#39;(%.2f, %.2f) &#39; % erange_from_option+\</span>
                                <span class="c">#&#39;is incompatible with that of the data &#39;+\</span>
                                <span class="c">#&#39;file (%.2f, %.2f)&#39; % erange</span>
          <span class="c">#else:</span>
            <span class="c">#eranges[erind] = erange_from_option</span>

        <span class="c">## rescale the matrix</span>
        <span class="c">#mat, params = resc.rescale(mat, erange=eranges[0], omp=self.opts.omp)</span>
        <span class="c">#### copy=False not working???</span>

        <span class="c">## cycle states</span>
        <span class="c">#assert spr &lt;= len(inds), &#39;spr value cannot be higher than #indices&#39;</span>
        <span class="c">#for sind in xrange(spr):</span>
          <span class="c">## check abort criterions</span>
          <span class="c">#is_converged, count_reached = [], []</span>
          <span class="c">#for mean, converge in zip(means, converges):</span>
            <span class="c">#is_converged.append(converge.check(mean.mean()) if tol else False)</span>
            <span class="c">#count_reached.append(mean.count &gt;= ssize if ssize else False)</span>
          <span class="c">#if until.check() or abort.check() or term.check() \</span>
          <span class="c">#or all(is_converged) or all(count_reached):</span>
            <span class="c">##print &#39;break2&#39;</span>
            <span class="c">#break</span>

          <span class="c">## calculate LDOS</span>
          <span class="c">## erange isn&#39;t needed if rescaled is True</span>
          <span class="c">#densities = ldosfunc(mat, limit=limits, rescaled=True,</span>
                               <span class="c">#rcstr=self.opts.rcstr,</span>
                               <span class="c">#intervals=self.opts.intervals,</span>
                               <span class="c">#kernel=self.opts.kernel, state=inds[sind],</span>
                               <span class="c">#num_threads=self.opts.num_threads)</span>
          <span class="c">#energ = densities[0].x</span>
          <span class="c">#scaleback = True</span>

          <span class="c">## add data to iterative averaging object</span>
          <span class="c">## scale density back to original energy spectrum (devide by &quot;a&quot;)</span>
          <span class="c">#for mean, density in zip(means, densities):</span>
            <span class="c">#mean.add(density.y.real/params[0])</span>

          <span class="c">## report progress</span>
          <span class="c">#min_count = min([mean.count for mean in means])</span>
          <span class="c">#max_acc = max([converge.delta()*100 for converge in converges])</span>
          <span class="c">#mon.update(min_count=min_count, max_acc=max_acc)</span>
          <span class="c">#bar.step()</span>

      <span class="c">## scale energy back to original energy spectrum</span>
      <span class="c">#if scaleback:</span>
        <span class="c">#energ = resc.inverse_rescale(energ, params)</span>
        <span class="c">#for eind in xrange(len(energs)):</span>
          <span class="c">#energs[eind] = energ</span>

      <span class="c">## create new coFunc objects</span>
      <span class="c">#for mean, energ, limit, erange, params, acc, outname in \</span>
      <span class="c">#zip(means, energs, limits, eranges, paramses, accs, self.outnames):</span>
        <span class="c">#if mean.count:</span>
          <span class="c">#aldos = cofunc.coFunc(energ, mean.mean())</span>
          <span class="c">#aldos.attrs.params    = params</span>
          <span class="c">#aldos.attrs.tol       = tol</span>
          <span class="c">#aldos.attrs.ssize     = ssize</span>
          <span class="c">#aldos.attrs.spr       = spr</span>
          <span class="c">#aldos.attrs.count     = mean.count</span>
          <span class="c">#aldos.attrs.var       = mean.var()</span>
          <span class="c">#aldos.attrs.ci        = mean.ci()</span>
          <span class="c">#aldos.attrs.acc       = converge.delta() \</span>
                                  <span class="c">#if converge.delta() != -1 else acc</span>
          <span class="c">#aldos.attrs.rcount    = rcount</span>
          <span class="c">#aldos.attrs.limit     = limit</span>
          <span class="c">#aldos.attrs.erange    = erange</span>
          <span class="c">#self.outfile[outname] = aldos</span>

      <span class="c">## finalize progress bar and progress monitor</span>
      <span class="c">#mon.set_delay(0)</span>
      <span class="c">#min_count = min([mean.count for mean in means])</span>
      <span class="c">#max_acc = max([converge.delta()*100 for converge in converges])</span>
      <span class="c">#mon.update(min_count=min_count, max_acc=max_acc)</span>

    <span class="c">## report that the timelimit has been reached</span>
    <span class="c">#if until.check():</span>
      <span class="c">#print &#39;Timelimit has been reached (%s).&#39; % time.ctime(until.timestamp)</span>

    <span class="c">## report if the TERM signal has been received</span>
    <span class="c">#if term.check():</span>
      <span class="c">#print &#39;Process has been terminated&#39;</span>

    <span class="c">## report if the process has been aborted by key press</span>
    <span class="c">#if abort.check():</span>
      <span class="c">#print &#39;Process has been aborted by key press&#39;</span>


<span class="c">#class _gldos_many(AveragingLDOS_KPMHDP00i):</span>
  <span class="c">#&quot;&quot;&quot;Calculate geometric mean of local density of states (typical density</span>
  <span class="c">#of states) for many different truncation numbers at once.</span>

  <span class="c">#All results will be saved into the same file, named &quot;gldos100&quot;, &quot;gldos200&quot;,</span>
  <span class="c">#etc. according to the chosen truncation numbers.&quot;&quot;&quot;</span>
  <span class="c">#__created__ = &#39;2013-06-02&#39;</span>
  <span class="c">#__modified__ = &#39;2013-06-19&#39;</span>
  <span class="c">## based on tb.kpm2._aldos_many (developed 2013-06-01 until 2013-06-02)</span>
  <span class="c">## based on tb.kpm2._aldos (developed 2012-09-03 until 2012-10-09)</span>
  <span class="c">## based on tb.kpm._Ados (developed from 2012-04-26 until 2012-07-16) and</span>
  <span class="c">## on tb.kpm._Gdos (developed from 2011-12-20 until 2012-07-17)</span>
  <span class="c">## based on tb.kpm._Gdos from 2011-12-20 until 2012-04-18</span>
  <span class="c">#innames = [&#39;__scell__&#39;]</span>
  <span class="c">#outnames = [] # names will be determined later (aldos100, aldos500, ...)</span>
  <span class="c">#__autoinst__ = True</span>

  <span class="c">#def prepare(self):</span>
    <span class="c">## get truncation limit</span>
    <span class="c">##size = self.infile.__scell__.size() # how to enable this?</span>
    <span class="c">#self.limits_from_option = self.get_limits(self.opts.limit) # size</span>

    <span class="c">## determine outnames</span>
    <span class="c">#self.outnames = [&#39;gldos%i&#39; % limit for limit in self.limits_from_option]</span>

  <span class="c">#def main(self):</span>
    <span class="c">## make sure a supercell definition is given</span>
    <span class="c">#if not isinstance(self.infile.__scell__, tb.sc.SuperCell):</span>
      <span class="c">#raise ValueError, &#39;expecting supercell definition&#39;</span>

    <span class="c">## instantiate LDOS HDP</span>
    <span class="c">#ldosfunc = _ldos_many()</span>

    <span class="c">## understand sample size option</span>
    <span class="c">#ssize, tol, digits = tb.misc.get_num_or_acc(self.opts.ssize)</span>

    <span class="c">## instantiate converge handlers</span>
    <span class="c">#converges = []</span>
    <span class="c">#for limit in self.limits_from_option:</span>
      <span class="c">#converges.append(progress.Converge(tol=tol, smooth=self.opts.smooth))</span>

    <span class="c">#with progress.Abort() as abort, \</span>
         <span class="c">#progress.Until(self.opts.until) as until, \</span>
         <span class="c">#progress.Terminate() as term, \</span>
         <span class="c">#progress.Monitor(formats=dict(max_acc=&#39;%.&#39;+str(digits)+&#39;f%%&#39;),</span>
                          <span class="c">#order=[&#39;min_count&#39;],</span>
                          <span class="c">#verbose=(self.opts.verbose and tol)) as mon, \</span>
         <span class="c">#progress.Bar(ssize, text=&#39;calculate GLDOS&#39;,</span>
                      <span class="c">#verbose=(self.opts.verbose and ssize)) as bar:</span>

      <span class="c">## as soon as the matrix has been rescaled for the first time and a</span>
      <span class="c">## rescaled energy array is retrieved from the core module, set this</span>
      <span class="c">## to True</span>
      <span class="c">## so basically this is True when at least one for-loop iteration has</span>
      <span class="c">## been done</span>
      <span class="c">#scaleback = False</span>

      <span class="c">## get previous results to continue calculation</span>
      <span class="c">#energs, denses, counts, accs, limits, eranges, vars, paramses \</span>
      <span class="c">#= [], [], [], [], [], [], [], []</span>
      <span class="c">#for outname in self.outnames:</span>
        <span class="c">#if outname in self.infile:</span>
          <span class="c">#energ  = self.infile[outname].x</span>
          <span class="c">#dens   = self.infile[outname].y</span>
          <span class="c">#count  = self.infile[outname].attrs.count</span>
          <span class="c">#acc    = self.infile[outname].attrs.acc</span>
          <span class="c">#limit  = self.infile[outname].attrs.limit</span>
          <span class="c">#erange = self.infile[outname].attrs.erange</span>
          <span class="c">#var    = self.infile[outname].attrs.var</span>
          <span class="c">##ci     = self.infile[outname].attrs.ci</span>
          <span class="c">#params = self.infile[outname].attrs.params</span>
        <span class="c">#else:</span>
          <span class="c">#energ  = None</span>
          <span class="c">#dens   = None</span>
          <span class="c">#count  = 0</span>
          <span class="c">#acc    = -1</span>
          <span class="c">#limit  = None</span>
          <span class="c">#erange = (None, None)</span>
          <span class="c">#var    = None</span>
          <span class="c">##ci     = None</span>
          <span class="c">#params = (None, None)</span>
        <span class="c">#energs.append(energ)</span>
        <span class="c">#denses.append(dens)</span>
        <span class="c">#counts.append(count)</span>
        <span class="c">#accs.append(acc)</span>
        <span class="c">#limits.append(limit)</span>
        <span class="c">#eranges.append(erange)</span>
        <span class="c">#vars.append(var)</span>
        <span class="c">#paramses.append(params)</span>

      <span class="c">## all energy ranges from the file have to be equal</span>
      <span class="c">### what if the user want to add a new limit? It would be None first!</span>
      <span class="c">#for erange in eranges[1:]:</span>
        <span class="c">#if eranges[0] != erange:</span>
          <span class="c">#raise ValueError, &#39;all energy ranges from the files must be equal&#39;</span>

      <span class="c">## get number of states per realizations of which the LDOS will be taken</span>
      <span class="c">## into account</span>
      <span class="c">#spr = self.get_spr(self.opts.spr, self.infile.__scell__)</span>

      <span class="c">## initialize geometric average calculators</span>
      <span class="c">#means = []</span>
      <span class="c">#for outname, dens, count, var in \</span>
      <span class="c">#zip(self.outnames, denses, counts, vars):</span>
        <span class="c">#means.append(oalg.gMean(init_value=dens, init_count=count,</span>
                                <span class="c">#init_var=var))</span>

      <span class="c">## the progress bar may jump ahead if a fixed sample size is given</span>
      <span class="c">#if ssize and not abort.check() and not term.check() \</span>
      <span class="c">#and not until.check():</span>
        <span class="c">#min_count = min([mean.count for mean in means])</span>
        <span class="c">#bar.jump(min_count)</span>

      <span class="c">## check truncation limit</span>
      <span class="c">#for lind in xrange(len(limits)):</span>
        <span class="c">#if limits[lind]:</span>
          <span class="c">#if self.limits_from_option[lind] != limits[lind]:</span>
            <span class="c">#raise ValueError, &#39;given truncation limit #%i&#39; % (lind+1)+\</span>
                              <span class="c">#&#39;(%i) is &#39; % limits_from_option[lind]+\</span>
                              <span class="c">#&#39;incompatible with the one from the data &#39;+\</span>
                              <span class="c">#&#39;file (%i)&#39; % limits[lind]</span>
        <span class="c">#else:</span>
          <span class="c">#limits[lind] = self.limits_from_option[lind]</span>

      <span class="c">## cycle realizations</span>
      <span class="c">#rcount = 0 # count realizations</span>
      <span class="c">#while not until.check() and not abort.check() \</span>
      <span class="c">#and not term.check():</span>

        <span class="c">## test if all converged or all have reached the requested sample size</span>
        <span class="c">#is_converged, count_reached = [], []</span>
        <span class="c">#for mean, converge in zip(means, converges):</span>
          <span class="c">#is_converged.append(converge.check(mean.mean()) \</span>
                                             <span class="c">#if tol else False)</span>
          <span class="c">#count_reached.append(mean.count &gt;= ssize if ssize else False)</span>
        <span class="c">##print &#39;is_converged&#39;, is_converged, len(is_converged)</span>
        <span class="c">##print &#39;count_reached&#39;, count_reached, len(count_reached)</span>
        <span class="c">#if all(is_converged) or all(count_reached):</span>
          <span class="c">##print &#39;break1&#39;</span>
          <span class="c">#break</span>

        <span class="c">## get matrix of new disorder realization</span>
        <span class="c">#mat, stateclasses = self.infile.__scell__.tbmat(distinguish=True)</span>
        <span class="c">##print &#39;stateclass lengths:&#39;, str([len(sc) for sc in stateclasses])</span>
        <span class="c">#inds = self.get_stateclass(self.opts.stateclass, stateclasses)</span>
        <span class="c">##print self.opts.stateclass, inds</span>
        <span class="c">#random.shuffle(inds)</span>
        <span class="c">#rcount += 1</span>

        <span class="c">## get energy range</span>
        <span class="c">### as all eranges are checked equal earlier, we would actually just</span>
        <span class="c">### need to compare with one of them</span>
        <span class="c">#erange_from_option = self.get_erange(self.opts.erange, mat)</span>
        <span class="c">#for erind, erange in enumerate(eranges):</span>
          <span class="c">#if erange[0] and erange[1]:</span>
            <span class="c">#if erange_from_option != erange:</span>
              <span class="c">#raise ValueError, &#39;given energy range &#39;+\</span>
                                <span class="c">#&#39;(%.2f, %.2f) &#39; % erange_from_option+\</span>
                                <span class="c">#&#39;is incompatible with that of the data &#39;+\</span>
                                <span class="c">#&#39;file (%.2f, %.2f)&#39; % erange</span>
          <span class="c">#else:</span>
            <span class="c">#eranges[erind] = erange_from_option</span>

        <span class="c">## rescale the matrix</span>
        <span class="c">#mat, params = resc.rescale(mat, erange=eranges[0],</span>
                                   <span class="c">#omp=self.opts.omp)</span>
        <span class="c">### copy=False not working?</span>

        <span class="c">## cycle states</span>
        <span class="c">#assert spr &lt;= len(inds), &#39;spr value cannot be higher than #indices&#39;</span>
        <span class="c">#for sind in xrange(spr):</span>
          <span class="c">## check abort criterions</span>
          <span class="c">#is_converged, count_reached = [], []</span>
          <span class="c">#for mean, converge in zip(means, converges):</span>
            <span class="c">#is_converged.append(converge.check(mean.mean()) \</span>
                                <span class="c">#if tol else False)</span>
            <span class="c">#count_reached.append(mean.count &gt;= ssize if ssize else False)</span>
          <span class="c">#if until.check() or abort.check() or term.check() \</span>
          <span class="c">#or all(is_converged) or all(count_reached):</span>
            <span class="c">##print &#39;break2&#39;</span>
            <span class="c">#break</span>

          <span class="c">## calculate LDOS</span>
          <span class="c">## erange isn&#39;t needed if rescaled is True</span>
          <span class="c">#densities = ldosfunc(mat, limit=limits, rescaled=True,</span>
                               <span class="c">#rcstr=self.opts.rcstr,</span>
                               <span class="c">#intervals=self.opts.intervals,</span>
                               <span class="c">#kernel=self.opts.kernel, state=inds[sind],</span>
                               <span class="c">#num_threads=self.opts.num_threads)</span>
          <span class="c">#energ = densities[0].x</span>
          <span class="c">#scaleback = True</span>

          <span class="c">#print densities[0].y</span>

          <span class="c">## add data to iterative averaging object</span>
          <span class="c">## scale density back to original energy spectrum (devide by &quot;a&quot;)</span>
          <span class="c">#for mean, density in zip(means, densities):</span>
            <span class="c">#mean.add(density.y.real/params[0])</span>

          <span class="c">## report progress</span>
          <span class="c">#min_count = min([mean.count for mean in means])</span>
          <span class="c">#max_acc = max([converge.delta()*100 for converge in converges])</span>
          <span class="c">#mon.update(min_count=min_count, max_acc=max_acc)</span>
          <span class="c">#bar.step()</span>

      <span class="c">## scale energy back to original energy spectrum</span>
      <span class="c">#if scaleback:</span>
        <span class="c">#energ = resc.inverse_rescale(energ, params)</span>
        <span class="c">#for eind in xrange(len(energs)):</span>
          <span class="c">#energs[eind] = energ</span>

      <span class="c">## create new coFunc objects</span>
      <span class="c">#for mean, energ, limit, erange, params, acc, outname in \</span>
      <span class="c">#zip(means, energs, limits, eranges, paramses, accs, self.outnames):</span>
        <span class="c">#if mean.count:</span>
          <span class="c">#gldos = cofunc.coFunc(energ, mean.mean())</span>
          <span class="c">#gldos.attrs.params    = params</span>
          <span class="c">#gldos.attrs.tol       = tol</span>
          <span class="c">#gldos.attrs.ssize     = ssize</span>
          <span class="c">#gldos.attrs.spr       = spr</span>
          <span class="c">#gldos.attrs.count     = mean.count</span>
          <span class="c">#gldos.attrs.var       = mean.var()</span>
          <span class="c">#gldos.attrs.ci        = mean.ci()</span>
          <span class="c">#gldos.attrs.acc       = converge.delta() \</span>
                                  <span class="c">#if converge.delta() != -1 else acc</span>
          <span class="c">#gldos.attrs.rcount    = rcount</span>
          <span class="c">#gldos.attrs.limit     = limit</span>
          <span class="c">#gldos.attrs.erange    = erange</span>
          <span class="c">#self.outfile[outname] = gldos</span>

      <span class="c">## finalize progress bar and progress monitor</span>
      <span class="c">#mon.set_delay(0)</span>
      <span class="c">#min_count = min([mean.count for mean in means])</span>
      <span class="c">#max_acc = max([converge.delta()*100 for converge in converges])</span>
      <span class="c">#mon.update(min_count=min_count, max_acc=max_acc)</span>

    <span class="c">## report that the timelimit has been reached</span>
    <span class="c">#if until.check():</span>
      <span class="c">#print &#39;Timelimit has been reached (%s).&#39; % time.ctime(until.timestamp)</span>

    <span class="c">## report if the TERM signal has been received</span>
    <span class="c">#if term.check():</span>
      <span class="c">#print &#39;Process has been terminated&#39;</span>

    <span class="c">## report if the process has been aborted by key press</span>
    <span class="c">#if abort.check():</span>
      <span class="c">#print &#39;Process has been aborted by key press&#39;</span>


<span class="c">#class _galdos(AveragingLDOS_KPMHDP00i):</span>
  <span class="c">#&quot;&quot;&quot;Calculate both geometric (typical average) and arithmetic mean of the</span>
  <span class="c">#local density of states at the same time, using each local density twice.</span>
  <span class="c">#In this way, the numerical effort is easily reduced by a factor of 2 if</span>
  <span class="c">#both types of averages are needed.&quot;&quot;&quot;</span>
  <span class="c">#__created__ = &#39;2012-09-03&#39;</span>
  <span class="c">#__modified__ = &#39;2013-06-20&#39;</span>
  <span class="c">## based on tb.kpm2._gldos (developed 2012-09-03 until 2012-09-11)</span>
  <span class="c">## and tb.kpm2._aldos (developed 2012-09-03 until 2012-09-11)</span>
  <span class="c">#innames = [&#39;__scell__&#39;]</span>
  <span class="c">#outnames = [&#39;gldos&#39;, &#39;aldos&#39;]</span>
  <span class="c">#__autoinst__ = True</span>

  <span class="c">#def main(self):</span>
    <span class="c">## make sure that a supercell definition is given</span>
    <span class="c">#if not isinstance(self.infile.__scell__, tb.sc.SuperCell):</span>
      <span class="c">#raise ValueError, &#39;expecting supercell definition&#39;</span>

    <span class="c">## instantiate LDOS HDP</span>
    <span class="c">#ldosfunc = _ldos()</span>

    <span class="c">## understand sample size option</span>
    <span class="c">#ssize, tol, digits = tb.misc.get_num_or_acc(self.opts.ssize)</span>

    <span class="c">#with progress.Abort() as abort, \</span>
         <span class="c">#progress.Converge(tol=tol, smooth=self.opts.smooth) as gconverge, \</span>
         <span class="c">#progress.Converge(tol=tol, smooth=self.opts.smooth) as aconverge, \</span>
         <span class="c">#progress.Until(self.opts.until) as until, \</span>
         <span class="c">#progress.Terminate() as term, \</span>
         <span class="c">#progress.Monitor(formats=dict(gacc=&#39;%.&#39;+str(digits)+&#39;f%%&#39;,</span>
                                       <span class="c">#aacc=&#39;%.&#39;+str(digits)+&#39;f%%&#39;),</span>
                          <span class="c">#order=[&#39;gcount&#39;, &#39;gacc&#39;, &#39;acount&#39;, &#39;aacc&#39;],</span>
                          <span class="c">#verbose=(self.opts.verbose and tol)) as mon, \</span>
         <span class="c">#progress.Bar(ssize, text=&#39;calculate GLDOS and ALDOS&#39;,</span>
                      <span class="c">#verbose=(self.opts.verbose and ssize)) as bar:</span>

      <span class="c">## as soon as the matrix has been rescaled for the first time and a</span>
      <span class="c">## rescaled energy array is retrieved from the core module, set this</span>
      <span class="c">## to True</span>
      <span class="c">## so basically this is True when at least one for-loop iteration has</span>
      <span class="c">## been done</span>
      <span class="c">#scaleback = False</span>

      <span class="c">## get previous results to continue calculation</span>
      <span class="c">#if &#39;gldos&#39; in self.infile:</span>
        <span class="c">#energ  = self.infile.gldos.x</span>
        <span class="c">#gdens   = self.infile.gldos.y</span>
        <span class="c">#gcount  = self.infile.gldos.attrs.count</span>
        <span class="c">#gacc    = self.infile.gldos.attrs.acc</span>
        <span class="c">#glimit  = self.infile.gldos.attrs.limit</span>
        <span class="c">#gerange = self.infile.gldos.attrs.erange</span>
        <span class="c">#gvar    = self.infile.gldos.attrs.var</span>
        <span class="c">#gparams = self.infile.gldos.attrs.params</span>
      <span class="c">#else:</span>
        <span class="c">#energ  = None</span>
        <span class="c">#gdens   = None</span>
        <span class="c">#gcount  = 0</span>
        <span class="c">#gacc    = -1</span>
        <span class="c">#glimit  = None</span>
        <span class="c">#gerange = (None, None)</span>
        <span class="c">#gvar    = None</span>
        <span class="c">#gparams = (None, None)</span>
      <span class="c">#if &#39;aldos&#39; in self.infile:</span>
        <span class="c">#energ  = self.infile.aldos.x</span>
        <span class="c">#adens   = self.infile.aldos.y</span>
        <span class="c">#acount  = self.infile.aldos.attrs.count</span>
        <span class="c">#aacc    = self.infile.aldos.attrs.acc</span>
        <span class="c">#alimit  = self.infile.aldos.attrs.limit</span>
        <span class="c">#aerange = self.infile.aldos.attrs.erange</span>
        <span class="c">#avar    = self.infile.aldos.attrs.var</span>
        <span class="c">#aparams = self.infile.aldos.attrs.params</span>
      <span class="c">#else:</span>
        <span class="c">#energ  = None</span>
        <span class="c">#adens   = None</span>
        <span class="c">#acount  = 0</span>
        <span class="c">#aacc    = -1</span>
        <span class="c">#alimit  = None</span>
        <span class="c">#aerange = (None, None)</span>
        <span class="c">#avar    = None</span>
        <span class="c">#aparams = (None, None)</span>

      <span class="c">#if aparams != gparams:</span>
        <span class="c">#raise ValueError, &#39;GLDOS and ALDOS in file %s &#39; \</span>
                          <span class="c">#% self.infile.filename+\</span>
                          <span class="c">#&#39;have different rescaling parameters&#39;</span>
      <span class="c">#params = aparams</span>

      <span class="c">## get number of states per realizations of which the LDOS will be taken</span>
      <span class="c">## into account</span>
      <span class="c">#spr = self.get_spr(self.opts.spr, self.infile.__scell__)</span>

      <span class="c">## initialize arithmetic and geometric average calculators</span>
      <span class="c">#gmean = oalg.gMean(init_value=gdens, init_count=gcount,</span>
                         <span class="c">#init_var=gvar)</span>
      <span class="c">#amean = oalg.Mean(init_value=adens, init_count=acount,</span>
                        <span class="c">#init_var=avar)</span>

      <span class="c">## the progress bar may jump ahead if a fixed sample size is given</span>
      <span class="c">#if ssize and not abort.check() and not term.check() \</span>
      <span class="c">#and not until.check():</span>
        <span class="c">#bar.jump(min(gmean.count, amean.count))</span>

      <span class="c">## get truncation limit</span>
      <span class="c">#size = self.infile.__scell__.size()</span>
      <span class="c">#limit_from_option = self.get_limit(self.opts.limit, size)</span>
      <span class="c">#if glimit:</span>
        <span class="c">#if limit_from_option != glimit:</span>
          <span class="c">#raise ValueError, &#39;given truncation limit &#39;+\</span>
                            <span class="c">#&#39;(%i) is incompatible &#39; % limit_from_option+\</span>
                            <span class="c">#&#39;with the GLDOS limit from the data file &#39;+\</span>
                            <span class="c">#&#39;(%i)&#39; % glimit</span>
      <span class="c">#if alimit:</span>
        <span class="c">#if limit_from_option != alimit:</span>
          <span class="c">#raise ValueError, &#39;given truncation limit &#39;+\</span>
                            <span class="c">#&#39;(%i) is incompatible &#39; % limit_from_option+\</span>
                            <span class="c">#&#39;with the ALDOS limit from the data file &#39;+\</span>
                            <span class="c">#&#39;(%i)&#39; % alimit</span>
      <span class="c">#limit = limit_from_option</span>

      <span class="c">## initialize intervals in case the loop will never be entered</span>
      <span class="c">#params = (1., 0.)</span>
      <span class="c">#intervals = self.get_intervals(self.opts.intervals, limit, params)</span>

      <span class="c">## cycle realizations</span>
      <span class="c">#rcount = 0 # count realizations</span>
      <span class="c">#while not until.check() and not abort.check() and not term.check() \</span>
      <span class="c">#and (not tol or not gconverge.check(gmean.mean()) \</span>
                   <span class="c">#or not aconverge.check(amean.mean())) \</span>
      <span class="c">#and (not ssize or gmean.count &lt; ssize or amean.count &lt; ssize):</span>
        <span class="c">## get matrix of new disorder realization</span>
        <span class="c">##print time.ctime(), &#39;create matrix...&#39;</span>
        <span class="c">##print &#39;sizeof(scell) before:&#39;, asizeof.asizeof(self.infile.__scell__)</span>
        <span class="c">#mat, stateclasses = self.infile.__scell__.tbmat(distinguish=True,</span>
                                                        <span class="c">#format=&#39;csr&#39;)</span>
        <span class="c">##print &#39;sizeof(scell) after:&#39;, asizeof.asizeof(self.infile.__scell__)</span>
        <span class="c">##print time.ctime(), &#39;matrix created&#39;</span>
        <span class="c">##print time.ctime(), &#39;obtain stateclasses...&#39;</span>
        <span class="c">#inds = self.get_stateclass(self.opts.stateclass, stateclasses)</span>
        <span class="c">##print time.ctime(), &#39;stateclasses obtained&#39;</span>
        <span class="c">#random.shuffle(inds)</span>
        <span class="c">#rcount += 1</span>
        <span class="c">##print mat.nnz, len(mat.data)</span>

        <span class="c">## get energy range</span>
        <span class="c">#erange_from_option = self.get_erange(self.opts.erange, mat)</span>
        <span class="c">#if gerange[0] and gerange[1]:</span>
          <span class="c">#if erange_from_option != gerange:</span>
            <span class="c">#raise ValueError, &#39;given energy range &#39;+\</span>
                              <span class="c">#&#39;(%.2f, %.2f) &#39; % erange_from_option+\</span>
                              <span class="c">#&#39;is incompatible with the GLDOS erange from &#39;+\</span>
                              <span class="c">#&#39;the data file (%.2f, %.2f)&#39; % gerange</span>
        <span class="c">#if aerange[0] and aerange[1]:</span>
          <span class="c">#if erange_from_option != aerange:</span>
            <span class="c">#raise ValueError, &#39;given energy range &#39;+\</span>
                              <span class="c">#&#39;(%.2f, %.2f) &#39; % erange_from_option+\</span>
                              <span class="c">#&#39;is incompatible with the ALDOS erange from &#39;+\</span>
                              <span class="c">#&#39;the data file (%.2f, %.2f)&#39; % aerange</span>
        <span class="c">#erange = erange_from_option</span>

        <span class="c">## rescale the matrix</span>
        <span class="c">#mat, params = resc.rescale(mat, erange=erange, omp=self.opts.omp)</span>
        <span class="c">#### copy=False not working???</span>

        <span class="c">## get number of intervals or stepwidth</span>
        <span class="c">#intervals = self.get_intervals(self.opts.intervals, limit, params)</span>

        <span class="c">## cycle states</span>
        <span class="c">#assert spr &lt;= len(inds), &#39;spr value is waaay too high...&#39;</span>
        <span class="c">#for sind in xrange(spr):</span>
          <span class="c">## check abort criterions</span>
          <span class="c">#if until.check() or abort.check() or term.check() \</span>
          <span class="c">#or (tol and gconverge.check(gmean.mean())) \</span>
          <span class="c">#or (tol and aconverge.check(amean.mean())) \</span>
          <span class="c">#or (ssize and gmean.count &gt;= ssize and amean.count &gt;= ssize):</span>
            <span class="c">#break</span>

          <span class="c">## calculate LDOS</span>
          <span class="c">## (erange isn&#39;t needed here, because rescaled is True)</span>
          <span class="c">#energ, dens = ldosfunc(mat, limit=limit, rescaled=True,</span>
                                 <span class="c">#rcstr=self.opts.rcstr, intervals=intervals,</span>
                                 <span class="c">#kernel=self.opts.kernel, state=inds[sind],</span>
                                 <span class="c">#num_threads=self.opts.num_threads).xy()</span>
          <span class="c">#scaleback = True</span>

          <span class="c">## add data to iterative averaging objects</span>
          <span class="c">## scale density back to original energy spectrum (devide by &quot;a&quot;)</span>
          <span class="c">#try:</span>
            <span class="c">#### not nice, but avoid negative values</span>
            <span class="c">#gmean.add(abs(dens.real/params[0]))</span>
          <span class="c">#except ValueError:</span>
            <span class="c">#print &gt;&gt;sys.stderr, &#39;bug: dens.real =&#39;, dens.real</span>
            <span class="c">#raise</span>
          <span class="c">#amean.add(dens.real/params[0])</span>

          <span class="c">## report progress</span>
          <span class="c">#mon.update(gcount=gmean.count, gacc=gconverge.delta()*100,</span>
                     <span class="c">#acount=amean.count, aacc=aconverge.delta()*100)</span>
          <span class="c">#bar.step()</span>

      <span class="c">## scale energy back to original energy spectrum</span>
      <span class="c">#if scaleback:</span>
        <span class="c">#energ = resc.inverse_rescale(energ, params)</span>

      <span class="c">## create new coFunc object</span>
      <span class="c">#if gmean.count:</span>
        <span class="c">#gldos = cofunc.coFunc(energ, gmean.mean())</span>
        <span class="c">#gldos.attrs.params    = params</span>
        <span class="c">#gldos.attrs.tol       = tol</span>
        <span class="c">#gldos.attrs.ssize     = ssize</span>
        <span class="c">#gldos.attrs.spr       = spr</span>
        <span class="c">#gldos.attrs.count     = gmean.count</span>
        <span class="c">#gldos.attrs.var       = gmean.var()</span>
        <span class="c">#gldos.attrs.ci        = gmean.ci()</span>
        <span class="c">#gldos.attrs.acc       = gconverge.delta() \</span>
                                <span class="c">#if gconverge.delta() != -1 else gacc</span>
        <span class="c">#gldos.attrs.rcount    = rcount</span>
        <span class="c">#gldos.attrs.limit     = limit</span>
        <span class="c">#gldos.attrs.erange    = gerange</span>
        <span class="c">#gldos.attrs.intervals = intervals*params[0] \</span>
                                <span class="c">#if isinstance(intervals, float) \</span>
                                <span class="c">#else intervals</span>
        <span class="c">#gldos.attrs.ndisc     = len(energ)</span>
        <span class="c">#self.outfile.gldos = gldos</span>
      <span class="c">#if amean.count:</span>
        <span class="c">#aldos = cofunc.coFunc(energ, amean.mean())</span>
        <span class="c">#aldos.attrs.params    = params</span>
        <span class="c">#aldos.attrs.tol       = tol</span>
        <span class="c">#aldos.attrs.ssize     = ssize</span>
        <span class="c">#aldos.attrs.spr       = spr</span>
        <span class="c">#aldos.attrs.count     = amean.count</span>
        <span class="c">#aldos.attrs.var       = amean.var()</span>
        <span class="c">#aldos.attrs.ci        = amean.ci()</span>
        <span class="c">#aldos.attrs.acc       = aconverge.delta() \</span>
                                <span class="c">#if aconverge.delta() != -1 else aacc</span>
        <span class="c">#aldos.attrs.rcount    = rcount</span>
        <span class="c">#aldos.attrs.limit     = limit</span>
        <span class="c">#aldos.attrs.erange    = aerange</span>
        <span class="c">#aldos.attrs.intervals = intervals*params[0] \</span>
                                <span class="c">#if isinstance(intervals, float) \</span>
                                <span class="c">#else intervals</span>
        <span class="c">#aldos.attrs.ndisc     = len(energ)</span>
        <span class="c">#self.outfile.aldos = aldos</span>

      <span class="c">## finalize progress bar and progress monitor</span>
      <span class="c">#mon.set_delay(0)</span>
      <span class="c">#mon.update(gcount=gmean.count, gacc=gconverge.delta()*100,</span>
                  <span class="c">#acount=amean.count, aacc=aconverge.delta()*100)</span>

    <span class="c">## report that the timelimit has been reached</span>
    <span class="c">#if until.check():</span>
      <span class="c">#print &#39;Timelimit has been reached (%s).&#39; % time.ctime(until.timestamp)</span>

    <span class="c">## report if the TERM signal has been received</span>
    <span class="c">#if term.check():</span>
      <span class="c">#print &#39;Process has been terminated&#39;</span>

    <span class="c">## report if the process has been aborted by key press</span>
    <span class="c">#if abort.check():</span>
      <span class="c">#print &#39;Process has been aborted by key press&#39;</span>


<span class="c">#class KPMHDP(hdp.BaseHDP):</span>
  <span class="c">#&quot;&quot;&quot;Define shared properties of HDPs that implement or utilize KPM</span>
  <span class="c">#algorithms.&quot;&quot;&quot;</span>
  <span class="c">#__created__ =&#39;2012-08-25&#39;</span>
  <span class="c">#__modified__ = &#39;2013-06-20&#39;</span>
  <span class="c">## former tb.kpm.KPMHDP (developed 2011-11-28 until 2012-08-15)</span>
  <span class="c">#usage = &#39;%prog [options] datafile [datafile2 [datafile3 ...]]&#39;</span>
  <span class="c">#epilog = &quot;&quot;&quot;To do:</span>
  <span class="c">#--&gt; Use fast cosine transform for reconstruction (FCT, &quot;divide-and-conquer&quot;</span>
      <span class="c">#algorithm). Just imagine O(N*log(N)) instead of O(N**2)...&quot;&quot;&quot;</span>

  <span class="c">#def options(self):</span>
    <span class="c">#self.add_option(&#39;-e&#39;, &#39;--erange&#39;, dest=&#39;erange&#39;, default=None, type=str,</span>
                  <span class="c">#help=&#39;set energy range. If None, use Lanczos algorithm&#39;)</span>
    <span class="c">#self.add_option(&#39;-k&#39;, &#39;--kernel&#39;, default=&#39;jackson&#39;,</span>
                    <span class="c">#help=&#39;select kernel&#39;)</span>
    <span class="c">##self.add_option(&#39;-r&#39;, &#39;--rcstr&#39;, default=&#39;dct&#39;,</span>
                    <span class="c">##help=&#39;select reconstruction method&#39;)</span>
    <span class="c">#self.add_option(&#39;-l&#39;, &#39;--limit&#39;, dest=&#39;limit&#39;, default=&#39;100&#39;, type=str,</span>
                  <span class="c">#help=&#39;set truncation limit. If an integer is given, &#39;+\</span>
                       <span class="c">#&#39;it defines a constant limit. If a float is &#39;+\</span>
                       <span class="c">#&#39;given, or if the string ends with a percentage &#39;+\</span>
                       <span class="c">#&#39;sign (%), it defines the desired accuracy for &#39;+\</span>
                       <span class="c">#&#39;some convergence criterion. If an expression &#39;+\</span>
                       <span class="c">#&#39;containing a slash (/) is given, it defines &#39;+\</span>
                       <span class="c">#&#39;the desired ratio between truncation number &#39;+\</span>
                       <span class="c">#&#39;and system size, which will be obtained from &#39;+\</span>
                       <span class="c">#&#39;the supercell definition &#39;+\</span>
                       <span class="c">#&#39;inside the file (in shell mode)&#39;)</span>
    <span class="c">#self.add_option(&#39;-o&#39;, &#39;--omp&#39;, default=False, action=&#39;store_true&#39;,</span>
                    <span class="c">#help=&#39;use OpenMP parallelized algorithms (where &#39;+\</span>
                         <span class="c">#&#39;possible)&#39;)</span>
    <span class="c">#self.add_option(&#39;-n&#39;, &#39;--num-threads&#39;, dest=&#39;num_threads&#39;, default=None,</span>
                  <span class="c">#type=int,</span>
                  <span class="c">#help=&#39;if not None, set number of OpenMP threads to use. &#39;+\</span>
                       <span class="c">#&#39;If smaller than 1, choose automatically &#39;+\</span>
                       <span class="c">#&#39;according to the number of processor cores&#39;)</span>
    <span class="c">#self.add_option(&#39;-u&#39;, &#39;--until&#39;, default=&#39;&#39;,</span>
                    <span class="c">#help=&#39;confine execution time&#39;)</span>
    <span class="c">#self.add_option(&#39;-i&#39;, &#39;--intervals&#39;, default=None, type=str,</span>
                    <span class="c">#help=&#39;set number of energy intervals. &#39;+\</span>
                         <span class="c">#&#39;If None, use twice the truncation limit. &#39;+\</span>
                         <span class="c">#&#39;If a float is given (a string including a point &#39;+\</span>
                         <span class="c">#&#39;&quot;.&quot;), the number is interpreted as the width of &#39;+\</span>
                         <span class="c">#&#39;each energy interval (&quot;Delta E&quot;). The number of &#39;+\</span>
                         <span class="c">#&#39;intervals is then determined based on this &#39;+\</span>
                         <span class="c">#&#39;Delta E and the energy range specified by &#39;+\</span>
                         <span class="c">#&#39;--erange&#39;)</span>

  <span class="c">#def prepare(self):</span>
    <span class="c">#if self.opts.omp:</span>
      <span class="c">#misc.set_num_threads(self.opts.num_threads)</span>

  <span class="c">#@staticmethod</span>
  <span class="c">#def get_limit(limitopt, size=None):</span>
    <span class="c">#&quot;&quot;&quot;Interprete given option string &quot;limitopt&quot;. If a ratio is given, this</span>
    <span class="c">#function needs the system size &quot;size&quot; (the ratio size/limit will be fixed</span>
    <span class="c">#then).&quot;&quot;&quot;</span>
    <span class="c">#__created__ = &#39;2012-08-25&#39;</span>
    <span class="c">#__modified__ = &#39;2012-09-04&#39;</span>
    <span class="c">## former tb.kpm.KPMHDP.get_limit (developed 2011-11-29 until 2012-07-16)</span>
    <span class="c">#if isinstance(limitopt, basestring) and &#39;/&#39; in limitopt:</span>
      <span class="c">## interprete as ratio between truncation number and system size</span>

      <span class="c">## make sure the division will result in a float (even if only integers</span>
      <span class="c">## are involved in the given expression)</span>
      <span class="c">#if not &#39;.&#39; in limitopt:</span>
        <span class="c">#limitopt += &#39;.&#39;</span>

      <span class="c">## evaluate expression</span>
      <span class="c">#ratio = eval(limitopt)</span>

      <span class="c">## get system size</span>
      <span class="c">#if size is None:</span>
        <span class="c">#raise ValueError, &#39;system size must be known if a constant ratio &#39;+\</span>
                          <span class="c">#&#39;system size/truncation limit is needed&#39;</span>
      <span class="c">#size = int(size)</span>

      <span class="c">## return limit</span>
      <span class="c">#return int(round(ratio*size))</span>
    <span class="c">#else:</span>
      <span class="c">#return int(limitopt)</span>

  <span class="c">#@staticmethod</span>
  <span class="c">#def get_limits(limitopt, size=None):</span>
    <span class="c">#&quot;&quot;&quot;Interprete given option string &quot;limitopt&quot;. If a ratio is given, this</span>
    <span class="c">#function needs information about the the system size (the ratio</span>
    <span class="c">#size/limit will be kept constant then). This version of the function</span>
    <span class="c">#can handle multiple comma-separated values, and will return a list of</span>
    <span class="c">#truncation limits as a result.&quot;&quot;&quot;</span>
    <span class="c">#__created__ = &#39;2013-05-31&#39;</span>
    <span class="c">#__modified__ = &#39;2013-06-02&#39;</span>
    <span class="c">## former tb.kpm.KPMHDP.get_limit (developed 2011-11-29 until 2012-07-16)</span>
    <span class="c">## based on tb.kpm.KPMHDP.get_limit (2012-08-25 until 2012-09-04)</span>
    <span class="c">#if isinstance(limitopt, basestring):</span>
      <span class="c">#values = []</span>
      <span class="c">#for element in limitopt.split(&#39;,&#39;):</span>
        <span class="c">#if &#39;/&#39; in element:</span>
          <span class="c">## interprete as ratio between truncation number and system size</span>

          <span class="c">## make sure the division will result in a float (even if only</span>
          <span class="c">## integers are involved in the given expression)</span>
          <span class="c">#if not &#39;.&#39; in element:</span>
            <span class="c">#element += &#39;.&#39;</span>

          <span class="c">## evaluate expression</span>
          <span class="c">#ratio = eval(element)</span>

          <span class="c">## get system size</span>
          <span class="c">#if size is None:</span>
            <span class="c">#raise ValueError, &#39;system size must be known if a constant &#39;+\</span>
                              <span class="c">#&#39;ratio system size/truncation limit is &#39;+\</span>
                              <span class="c">#&#39;requested&#39;</span>
          <span class="c">#size = int(size)</span>

          <span class="c">## return limit</span>
          <span class="c">#values.append(int(round(ratio*size)))</span>
        <span class="c">#else:</span>
          <span class="c">#values.append(int(element))</span>
    <span class="c">#else:</span>
      <span class="c">#values = [int(value) for value in limitopt]</span>

    <span class="c">## remove double entries, sort, and return</span>
    <span class="c">#values = list(set(values))</span>
    <span class="c">#values.sort()</span>
    <span class="c">#return values</span>

  <span class="c">#def get_erange(self, erange_option, mat):</span>
    <span class="c">#&quot;&quot;&quot;Get and check energy range. Can not be done before the matrix is</span>
    <span class="c">#loaded, so this is why this convenience method exists.&quot;&quot;&quot;</span>
    <span class="c">#__created__ = &#39;2012-09-04&#39;</span>
    <span class="c">#__modified__ = &#39;2012-09-04&#39;</span>
    <span class="c">## copied from tb.kpm.KPMHDP.get_erange (2011-11-29 until 2012-08-15)</span>

    <span class="c">## get and check option</span>
    <span class="c">#erange = tb.misc.opt2mathlist(erange_option, dtype=float)</span>
    <span class="c">#if len(erange) &gt; 2:</span>
      <span class="c">#self.op.error(&#39;bad energy range&#39;)</span>

    <span class="c">## determine energy range</span>
    <span class="c">#if len(erange) &gt; 1:</span>
      <span class="c">## get energy range</span>
      <span class="c">#emin, emax = erange</span>
    <span class="c">#elif len(erange) &gt; 0:</span>
      <span class="c">## assume symmetric energy range</span>
      <span class="c">#if erange[0] &lt; 0:</span>
        <span class="c">#emin = erange[0]</span>
        <span class="c">#emax = -emin</span>
      <span class="c">#else:</span>
        <span class="c">#emax = erange[0]</span>
        <span class="c">#emin = -emax</span>
    <span class="c">#else:</span>
      <span class="c">## calculate highest and lowest eigenvalues using Lanczos algorithm</span>
      <span class="c">#bar = progress.Bar(1, &#39;use Lanczos algorithm to find energy range&#39;,</span>
                          <span class="c">#verbose=self.opts.verbose)</span>
      <span class="c">#### is Lanczos not working on the Blackpearl cluster?</span>
      <span class="c">#some_eigvals = scipy.sparse.linalg.eigs(mat, k=12, which=&#39;LM&#39;,</span>
                                              <span class="c">#return_eigenvectors=False)</span>
      <span class="c">#some_eigvals = some_eigvals.real</span>
      <span class="c">#emin = min(some_eigvals)</span>
      <span class="c">#emin -= abs(.1*emin) # Just add an extra 10 % to make sure no</span>
                            <span class="c">## eigenvalue lies outside the interval [-1, 1]</span>
      <span class="c">#emax = max(some_eigvals)</span>
      <span class="c">#emax += abs(.1*emax) # Just add an extra 10 % to make sure no</span>
                            <span class="c">## eigenvalue lies outside the interval [-1, 1]</span>
      <span class="c">#bar.step()</span>

    <span class="c">## return energy range</span>
    <span class="c">#return emin, emax</span>

  <span class="c">#@staticmethod</span>
  <span class="c">#def get_intervals(num_or_step, truncation_limit, rescale_params):</span>
    <span class="c">#&quot;&quot;&quot;Get number of intervals or stepwidth. If an integer or long is given</span>
    <span class="c">#(or a string not including a &quot;.&quot;), return number of intervals as an</span>
    <span class="c">#integer. If a float is given (or a string including a &quot;.&quot;), return the</span>
    <span class="c">#rescaled stepwidth according to the given rescale parameters. If None is</span>
    <span class="c">#given, return the integer 2*truncation_limit.&quot;&quot;&quot;</span>
    <span class="c">#__created__ = &#39;2013-06-20&#39;</span>
    <span class="c">#__modified__ = &#39;2013-06-20&#39;</span>
    <span class="c">#if num_or_step is None:</span>
      <span class="c">#return 2*truncation_limit</span>
    <span class="c">#if isinstance(num_or_step, basestring):</span>
      <span class="c">#if &#39;.&#39; in num_or_step:</span>
        <span class="c">#num_or_step = float(num_or_step)</span>
      <span class="c">#else:</span>
        <span class="c">#num_or_step = int(num_or_step)</span>
    <span class="c">#if isinstance(num_or_step, float):</span>
      <span class="c">## rescale</span>
      <span class="c">#num_or_step = num_or_step/rescale_params[0]</span>
      <span class="c">#return num_or_step</span>
    <span class="c">#else:</span>
      <span class="c">#num_or_step = int(num_or_step)</span>
      <span class="c">#return num_or_step</span>


<span class="c">##======================#</span>
<span class="c">## Averaging algorithms #</span>
<span class="c">##======================#</span>


<span class="c">#class AveragingLDOS_KPMHDP00i(KPMHDP00i):</span>
  <span class="c">#__created__ = &#39;2012-09-11&#39;</span>
  <span class="c">#__modified__ = &#39;2012-10-12&#39;</span>
  <span class="c">#__autoinst__ = False</span>

  <span class="c">#def options(self):</span>
    <span class="c">#self.add_option(&#39;-s&#39;, &#39;--sample-size&#39;, dest=&#39;ssize&#39;, default=&#39;1&#39;,</span>
                    <span class="c">#type=str,</span>
                    <span class="c">#help=&#39;set sample size. If string contains a decimal &#39;+\</span>
                         <span class="c">#&#39;point (.) or ends with a percent sign (%), &#39;</span>
                         <span class="c">#&#39;with &quot;ppm&quot; (parts per million) &#39;+\</span>
                         <span class="c">#&#39;or with &quot;ppb&quot; (parts per billion), &#39;+\</span>
                         <span class="c">#&#39;request a certain relative accuracy (dynamic &#39;+\</span>
                         <span class="c">#&#39;number of samples)&#39;)</span>
    <span class="c">#self.add_option(&#39;-p&#39;, &#39;--spr&#39;, dest=&#39;spr&#39;, default=&#39;1%&#39;, type=str,</span>
                    <span class="c">#help=&#39;set number of states per realization of which &#39;+\</span>
                        <span class="c">#&#39;the local density of states is taken into &#39;+\</span>
                        <span class="c">#&#39;account. If a float is given, or if the string &#39;+\</span>
                        <span class="c">#&#39;ends with a percent sign (%), &#39;+\</span>
                        <span class="c">#&#39;set the number relative to the &#39;+\</span>
                        <span class="c">#&#39;total number of states of the system (the rank &#39;+\</span>
                        <span class="c">#&#39;of the tight binding matrix)&#39;)</span>
    <span class="c">#self.add_option(&#39;-o&#39;, &#39;--smooth&#39;, dest=&#39;smooth&#39;, default=100,</span>
                    <span class="c">#help=&#39;set smoothness level for convergence criterion &#39;+\</span>
                        <span class="c">#&#39;(average over the given number of convergence &#39;+\</span>
                        <span class="c">#&#39;tests). Note that the program will make at &#39;+\</span>
                        <span class="c">#&#39;least this number of iterations before it &#39;+\</span>
                        <span class="c">#&#39;will actually check for convergence. &#39;+\</span>
                        <span class="c">#&#39;Only in effect if a dynamic number of samples &#39;+\</span>
                        <span class="c">#&#39;is chosen using the --sample-size option&#39;)</span>
    <span class="c">#self.add_option(&#39;-c&#39;, &#39;--stateclass&#39;, default=&#39;&#39;, type=str,</span>
                    <span class="c">#help=&#39;restrict selection of states to certain state &#39;+\</span>
                         <span class="c">#&#39;class(es). By default, select all&#39;)</span>
    <span class="c">##self.add_option(&#39;-r&#39;, &#39;--rcstr&#39;, default=&#39;dct&#39;, type=str,</span>
                    <span class="c">##help=&#39;set reconstruction method (std, dct)&#39;)</span>
    <span class="c">##self.add_option(&#39;-i&#39;, &#39;--intervals&#39;, default=None, type=int,</span>
                    <span class="c">##help=&#39;set number of energy intervals. &#39;+\</span>
                         <span class="c">##&#39;If None, use twice the truncation limit&#39;)</span>


  <span class="c">#def get_stateclass(self, stateclass_option, stateclasses):</span>
    <span class="c">#&quot;&quot;&quot;Return state indices according to the selected stateclass(es).&quot;&quot;&quot;</span>
    <span class="c">#__created__ = &#39;2012-09-04&#39;</span>
    <span class="c">#__created__ = &#39;2012-09-07&#39;</span>
    <span class="c">## copied from tb.kpm2._ldos.get_stateclass (2012-09-03 until 2012-09-04)</span>
    <span class="c">#if stateclass_option is None or not stateclass_option:</span>
      <span class="c">## by default, return all available indices</span>
      <span class="c">#return list(set(itertools.chain(*stateclasses)))</span>
    <span class="c">#else:</span>
      <span class="c">#classinds = stateclass_option.split(&#39;,&#39;)</span>
      <span class="c">#indices = []</span>
      <span class="c">#for classind in classinds:</span>
        <span class="c">#indices += stateclasses[int(classind)]</span>
      <span class="c">#return list(set(indices))</span>


<span class="c">##====================================#</span>
<span class="c">## helper to convert wrong error data #</span>
<span class="c">## can be deleted later...            #</span>
<span class="c">##====================================#</span>


<span class="c">#class _convert_stderr(hdp.HDP00i):</span>
  <span class="c">#&quot;&quot;&quot;Convert old (wrong) standard error (stderr) attributes of GLDOS and</span>
  <span class="c">#ALDOS to new (correct) variance (var), and confidence interval</span>
  <span class="c">#(ci). Will only convert if the attribute &quot;stderr&quot; is found.&quot;&quot;&quot;</span>
  <span class="c">#__created__ = &#39;2013-06-18&#39;</span>
  <span class="c">#__modified__ = &#39;2013-06-19&#39;</span>
  <span class="c">#__autoinst__ = True</span>
  <span class="c">#indep = True</span>
  <span class="c">#sfrom = ffrom = sto = fto = hdp.FILE</span>

  <span class="c">#def options(self):</span>
    <span class="c">#self.add_option(&#39;-n&#39;, &#39;--names&#39;, default=&#39;gldos,aldos&#39;,</span>
                    <span class="c">#help=&#39;set dataset names&#39;)</span>
    <span class="c">#self.add_option(&#39;-f&#39;, &#39;--force&#39;, default=False, action=&#39;store_true&#39;,</span>
                    <span class="c">#help=&#39;silently ignore non-existent datasets&#39;)</span>

  <span class="c">#def prepare(self):</span>
    <span class="c">#for name in self.opts.names.split(&#39;,&#39;):</span>
      <span class="c">#if not name in [&#39;gldos&#39;, &#39;aldos&#39;]:</span>
        <span class="c">#print &gt;&gt;sys.stderr, &#39;names may only include &quot;gldos&quot; and &quot;aldos&quot;&#39;</span>
        <span class="c">#return</span>

  <span class="c">#def main(self):</span>
    <span class="c">#for name in self.opts.names.split(&#39;,&#39;):</span>
      <span class="c">#if not name in self.infile:</span>
        <span class="c">#if self.opts.force:</span>
          <span class="c">#continue</span>
        <span class="c">#print &gt;&gt;sys.stderr, &#39;convert-stderr: dataset &quot;%s&quot; &#39; % name +\</span>
                            <span class="c">#&#39;not found in file &quot;%s&quot;&#39; % self.infile.filename</span>
        <span class="c">#return</span>
      <span class="c">#dset = self.infile[name]</span>
      <span class="c">#if not &#39;stderr&#39; in dset.attrs:</span>
        <span class="c">#if self.opts.force:</span>
          <span class="c">#continue</span>
        <span class="c">#print &gt;&gt;sys.stderr, &#39;convert-stderr: dataset &quot;%s&quot; &#39; % name +\</span>
                            <span class="c">#&#39;in file &quot;%s&quot; &#39; % self.infile.filename +\</span>
                            <span class="c">#&#39;does not have attribute attrs.stderr&#39;</span>
        <span class="c">#return</span>

      <span class="c">## convert</span>
      <span class="c">#stderr = dset.attrs.stderr if name == &#39;aldos&#39; \</span>
                <span class="c">#else numpy.log(dset.attrs.stderr)</span>
      <span class="c">#std = stderr*numpy.sqrt(dset.attrs.count-1)</span>
      <span class="c">#var = std**2</span>

      <span class="c">## save</span>
      <span class="c">#dset.attrs.var = var</span>
      <span class="c">#dset.attrs.ci = (stderr, stderr)</span>
      <span class="c">#del dset.attrs.stderr</span>
      <span class="c">#self.infile[name] = dset # overwrite with new version</span>


<span class="c">#class _convert_std(hdp.HDP00i):</span>
  <span class="c">#&quot;&quot;&quot;Convert old standard deviation (std) attributes of GLDOS and ALDOS to</span>
  <span class="c">#new variance (var), following the new guideline that only the sample</span>
  <span class="c">#variance should be saves alongside the GLDOS and ALDOS data. Also</span>
  <span class="c">#overwrites the confidence interval (ci). Conversion only takes place if the</span>
  <span class="c">#dataset &quot;std&quot; is found among the attributes of GLDOS and/or ALDOS.&quot;&quot;&quot;</span>
  <span class="c">#__created__ = &#39;2013-06-18&#39;</span>
  <span class="c">#__modified__ = &#39;2013-06-19&#39;</span>
  <span class="c">#__autoinst__ = True</span>
  <span class="c">#indep = True</span>
  <span class="c">#sfrom = ffrom = sto = fto = hdp.FILE</span>

  <span class="c">#def options(self):</span>
    <span class="c">#self.add_option(&#39;-n&#39;, &#39;--names&#39;, default=&#39;gldos,aldos&#39;,</span>
                    <span class="c">#help=&#39;set dataset names&#39;)</span>
    <span class="c">#self.add_option(&#39;-f&#39;, &#39;--force&#39;, default=False, action=&#39;store_true&#39;,</span>
                    <span class="c">#help=&#39;silently ignore non-existent datasets&#39;)</span>

  <span class="c">#def prepare(self):</span>
    <span class="c">#for name in self.opts.names.split(&#39;,&#39;):</span>
      <span class="c">#if not name in [&#39;gldos&#39;, &#39;aldos&#39;]:</span>
        <span class="c">#print &gt;&gt;sys.stderr, &#39;names may only include &quot;gldos&quot; and &quot;aldos&quot;&#39;</span>
        <span class="c">#return</span>

  <span class="c">#def main(self):</span>
    <span class="c">#for name in self.opts.names.split(&#39;,&#39;):</span>
      <span class="c">#if not name in self.infile:</span>
        <span class="c">#if self.opts.force:</span>
          <span class="c">#continue</span>
        <span class="c">#print &gt;&gt;sys.stderr, &#39;convert-std: dataset &quot;%s&quot; &#39; % name +\</span>
                            <span class="c">#&#39;not found in file &quot;%s&quot;&#39; % self.infile.filename</span>
        <span class="c">#return</span>
      <span class="c">#dset = self.infile[name]</span>
      <span class="c">#if not &#39;std&#39; in dset.attrs:</span>
        <span class="c">#if self.opts.force:</span>
          <span class="c">#continue</span>
        <span class="c">#print &gt;&gt;sys.stderr, &#39;convert-std: dataset &quot;%s&quot; &#39; % name +\</span>
                            <span class="c">#&#39;in file &quot;%s&quot; &#39; % self.infile.filename +\</span>
                            <span class="c">#&#39;does not have attribute attrs.std&#39;</span>
        <span class="c">#return</span>

      <span class="c">## convert</span>
      <span class="c">#var = dset.attrs.std**2</span>
      <span class="c">#stderr = dset.attrs.std/numpy.sqrt(dset.attrs.count-1)</span>

      <span class="c">## save</span>
      <span class="c">#dset.attrs.var = var</span>
      <span class="c">#dset.attrs.ci = (stderr, stderr)</span>
      <span class="c">#del dset.attrs.std</span>
      <span class="c">#self.infile[name] = dset # overwrite with new version</span>

</div>
<div class="viewcode-block" id="_get_stateclass"><a class="viewcode-back" href="../index.html#kpm._get_stateclass">[docs]</a><span class="k">def</span> <span class="nf">_get_stateclass</span><span class="p">(</span><span class="n">stateclass_option</span><span class="p">,</span> <span class="n">stateclasses</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return state indices according to the selected stateclass(es).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">stateclass_option</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">stateclass_option</span><span class="p">:</span>
        <span class="c"># by default, return all available indices</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">stateclasses</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">classinds</span> <span class="o">=</span> <span class="n">stateclass_option</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">classind</span> <span class="ow">in</span> <span class="n">classinds</span><span class="p">:</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">classind</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>


<span class="c">#def get_states(self, state_option, inds):</span>
  <span class="c">#&quot;&quot;&quot;Get indices of the states selected by the state option. Choose from the</span>
  <span class="c">#given index list &quot;inds&quot;.&quot;&quot;&quot;</span>
  <span class="c">##former tb.kpm._Ldos.get_state (2011-11-29)</span>

  <span class="c">## get available indices</span>
  <span class="c">#inds = list(inds)</span>
  <span class="c">#inds.sort()</span>
  <span class="c">#inds = scipy.array(inds)</span>

  <span class="c">## process state option</span>
  <span class="c">#if isinstance(state_option, basestring) and state_option.startswith(&#39;r&#39;):</span>
    <span class="c">## choose a given number of random states</span>
    <span class="c">#nstates = int(state_option[1:])</span>
    <span class="c">#assert nstates &gt;= 0</span>
    <span class="c">#sinds = list(inds[numpy.random.permutation(len(inds))[:nstates]])</span>
    <span class="c">#sinds.sort()</span>
  <span class="c">#elif state_option == &#39;:&#39;:</span>
    <span class="c">## choose all states (calculate total density of states)</span>
    <span class="c">#sinds = inds</span>
  <span class="c">#elif tb.misc.isiterable(state_option):</span>
    <span class="c">#sinds = list(state_option)</span>
  <span class="c">#elif isinstance(state_option, (int, long)):</span>
    <span class="c">#sinds = [int(state_option)]</span>
  <span class="c">#else:</span>
    <span class="c">#sinds = tb.misc.opt2ranges(state_option, upper=len(inds))</span>

  <span class="c">## check number of selected states</span>
  <span class="c">#if len(sinds) &lt; 1:</span>
    <span class="c">#self.op.error(&#39;number of states must be positive integer&#39;)</span>

  <span class="c">## store and return indices</span>
  <span class="c">#return list(sinds)</span>

</div>
<div class="viewcode-block" id="_get_energ"><a class="viewcode-back" href="../index.html#kpm._get_energ">[docs]</a><span class="k">def</span> <span class="nf">_get_energ</span><span class="p">(</span><span class="n">rcstr_func</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span> <span class="n">estep</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">rcstr_func</span> <span class="ow">is</span> <span class="n">rcstr</span><span class="o">.</span><span class="n">dct</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">estep</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;setting energy stepwidth not possible with DCT&#39;</span><span class="p">)</span>
        <span class="n">energ</span> <span class="o">=</span> <span class="n">disc</span><span class="o">.</span><span class="n">cosine</span><span class="p">(</span><span class="n">enum</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">rcstr_func</span> <span class="ow">is</span> <span class="n">rcstr</span><span class="o">.</span><span class="n">std</span><span class="p">:</span>
        <span class="n">energ</span> <span class="o">=</span> <span class="n">disc</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">enum</span> <span class="ow">or</span> <span class="n">estep</span> <span class="o">/</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;unknown reconstruction method: </span><span class="si">%s</span><span class="s">&#39;</span>
                         <span class="o">%</span> <span class="n">rcstr_func</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">energ</span>

</div>
<div class="viewcode-block" id="_get_rcstr_args"><a class="viewcode-back" href="../index.html#kpm._get_rcstr_args">[docs]</a><span class="k">def</span> <span class="nf">_get_rcstr_args</span><span class="p">(</span><span class="n">rcstr_func</span><span class="p">,</span> <span class="n">energ</span><span class="p">,</span> <span class="n">enum</span><span class="p">,</span> <span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">):</span>
    <span class="n">rcstr_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rcstr_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">omp</span><span class="o">=</span><span class="n">omp</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rcstr_func</span> <span class="ow">is</span> <span class="n">rcstr</span><span class="o">.</span><span class="n">std</span><span class="p">:</span>
        <span class="n">rcstr_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energ</span><span class="p">)</span>  <span class="c"># use uniform discretization in STD mode</span>
    <span class="k">elif</span> <span class="n">rcstr_func</span> <span class="ow">is</span> <span class="n">rcstr</span><span class="o">.</span><span class="n">dct</span><span class="p">:</span>
        <span class="n">rcstr_kwargs</span><span class="p">[</span><span class="s">&#39;ndisc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enum</span>  <span class="c"># pass number of intervals</span>
    <span class="k">return</span> <span class="n">rcstr_args</span><span class="p">,</span> <span class="n">rcstr_kwargs</span>


<span class="c">#def _get_spr(spr_option, scell):</span>
  <span class="c">#&quot;&quot;&quot;Interprete spr option to get number of states per realizations of which</span>
  <span class="c">#the LDOS will be taken into account. Needs the SuperCell instance.&quot;&quot;&quot;</span>
  <span class="c">## 2013-07-23 until 2013-07-23</span>
  <span class="c">## based on tb.kpm2.KPMHDP.get_spr (developed 2012-09-04 until 2012-09-07)</span>
  <span class="c">## copied from tb.kpm._Gdos.get_spr (developed 2012-02-24 until 2012-07-17)</span>
  <span class="c">#spr_option = str(spr_option)</span>
  <span class="c">#if spr_option[-1] == &#39;%&#39;:</span>
    <span class="c">#percent = float(spr_option[:-1])</span>
    <span class="c">#if percent &lt; 0 or percent &gt; 100:</span>
      <span class="c">#op.error(&#39;bad spr option: %s. &#39; % spr_option +\</span>
                    <span class="c">#&#39;Percentage must be from interval [0, 100]&#39;)</span>
    <span class="c">#spr = int(percent/100*scell.size()) # scell.nents()</span>
  <span class="c">#elif &#39;.&#39; in spr_option:</span>
    <span class="c">#ratio = float(spr_option[:-1])</span>
    <span class="c">#if ratio &lt; 0 or ratio &gt; 1:</span>
      <span class="c">#op.error(&#39;bad spr option: %s. &#39; % spr_option +\</span>
                    <span class="c">#&#39;Ratio must be from interval [0, 1]&#39;)</span>
    <span class="c">#spr = int(ratio*scell.size())</span>
  <span class="c">#else:</span>
    <span class="c">#spr = int(spr_option)</span>

  <span class="c">#if spr &lt; 1:</span>
    <span class="c">#spr = 1</span>
  <span class="c">#return spr</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">kpm 0.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Daniel Jung.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>